
//
// DO NOT EDIT
// 
// This file was automatically generated by generate_jai_wrapper.py and will be overwritten.
//

#module_parameters(LINK_STATIC := false);

    

//
// section: ENUMS
//

ImDrawCornerFlags :: enum_flags s32 {
    None        :: 0;
    TopLeft     :: 1 << 0;
    TopRight    :: 1 << 1;
    BotLeft     :: 1 << 2;
    BotRight    :: 1 << 3;
    Top         :: ImDrawCornerFlags.TopLeft | ImDrawCornerFlags.TopRight;
    Bot         :: ImDrawCornerFlags.BotLeft | ImDrawCornerFlags.BotRight;
    Left        :: ImDrawCornerFlags.TopLeft | ImDrawCornerFlags.BotLeft;
    Right       :: ImDrawCornerFlags.TopRight | ImDrawCornerFlags.BotRight;
    All         :: 0xF;
}

ImDrawListFlags :: enum_flags s32 {
    None                      :: 0;
    AntiAliasedLines          :: 1 << 0;
    AntiAliasedLinesUseTex    :: 1 << 1;
    AntiAliasedFill           :: 1 << 2;
    AllowVtxOffset            :: 1 << 3;
}

ImFontAtlasFlags :: enum_flags s32 {
    None                  :: 0;
    NoPowerOfTwoHeight    :: 1 << 0;
    NoMouseCursors        :: 1 << 1;
    NoBakedLines          :: 1 << 2;
}

Axis :: enum s32 {
    None    :: -1;
    X       :: 0;
    Y       :: 1;
}

BackendFlags :: enum_flags s32 {
    None                       :: 0;
    HasGamepad                 :: 1 << 0;
    HasMouseCursors            :: 1 << 1;
    HasSetMousePos             :: 1 << 2;
    RendererHasVtxOffset       :: 1 << 3;
    PlatformHasViewports       :: 1 << 10;
    HasMouseHoveredViewport    :: 1 << 11;
    RendererHasViewports       :: 1 << 12;
}

ButtonFlags :: enum_flags s32 {
    None                   :: 0;
    MouseButtonLeft        :: 1 << 0;
    MouseButtonRight       :: 1 << 1;
    MouseButtonMiddle      :: 1 << 2;
    MouseButtonMask_       :: ButtonFlags.MouseButtonLeft | ButtonFlags.MouseButtonRight | ButtonFlags.MouseButtonMiddle;
    MouseButtonDefault_    :: ButtonFlags.MouseButtonLeft;
}

Col :: enum s32 {
    Text                     :: 0;
    TextDisabled             :: 1;
    WindowBg                 :: 2;
    ChildBg                  :: 3;
    PopupBg                  :: 4;
    Border                   :: 5;
    BorderShadow             :: 6;
    FrameBg                  :: 7;
    FrameBgHovered           :: 8;
    FrameBgActive            :: 9;
    TitleBg                  :: 10;
    TitleBgActive            :: 11;
    TitleBgCollapsed         :: 12;
    MenuBarBg                :: 13;
    ScrollbarBg              :: 14;
    ScrollbarGrab            :: 15;
    ScrollbarGrabHovered     :: 16;
    ScrollbarGrabActive      :: 17;
    CheckMark                :: 18;
    SliderGrab               :: 19;
    SliderGrabActive         :: 20;
    Button                   :: 21;
    ButtonHovered            :: 22;
    ButtonActive             :: 23;
    Header                   :: 24;
    HeaderHovered            :: 25;
    HeaderActive             :: 26;
    Separator                :: 27;
    SeparatorHovered         :: 28;
    SeparatorActive          :: 29;
    ResizeGrip               :: 30;
    ResizeGripHovered        :: 31;
    ResizeGripActive         :: 32;
    Tab                      :: 33;
    TabHovered               :: 34;
    TabActive                :: 35;
    TabUnfocused             :: 36;
    TabUnfocusedActive       :: 37;
    DockingPreview           :: 38;
    DockingEmptyBg           :: 39;
    PlotLines                :: 40;
    PlotLinesHovered         :: 41;
    PlotHistogram            :: 42;
    PlotHistogramHovered     :: 43;
    TableHeaderBg            :: 44;
    TableBorderStrong        :: 45;
    TableBorderLight         :: 46;
    TableRowBg               :: 47;
    TableRowBgAlt            :: 48;
    TextSelectedBg           :: 49;
    DragDropTarget           :: 50;
    NavHighlight             :: 51;
    NavWindowingHighlight    :: 52;
    NavWindowingDimBg        :: 53;
    ModalWindowDimBg         :: 54;
    COUNT                    :: 55;
}

ColorEditFlags :: enum_flags s32 {
    None                :: 0;
    NoAlpha             :: 1 << 1;
    NoPicker            :: 1 << 2;
    NoOptions           :: 1 << 3;
    NoSmallPreview      :: 1 << 4;
    NoInputs            :: 1 << 5;
    NoTooltip           :: 1 << 6;
    NoLabel             :: 1 << 7;
    NoSidePreview       :: 1 << 8;
    NoDragDrop          :: 1 << 9;
    NoBorder            :: 1 << 10;
    AlphaBar            :: 1 << 16;
    AlphaPreview        :: 1 << 17;
    AlphaPreviewHalf    :: 1 << 18;
    HDR                 :: 1 << 19;
    DisplayRGB          :: 1 << 20;
    DisplayHSV          :: 1 << 21;
    DisplayHex          :: 1 << 22;
    Uint8               :: 1 << 23;
    Float               :: 1 << 24;
    PickerHueBar        :: 1 << 25;
    PickerHueWheel      :: 1 << 26;
    InputRGB            :: 1 << 27;
    InputHSV            :: 1 << 28;
    _OptionsDefault     :: ColorEditFlags.Uint8 | ColorEditFlags.DisplayRGB | ColorEditFlags.InputRGB | ColorEditFlags.PickerHueBar;
    _DisplayMask        :: ColorEditFlags.DisplayRGB | ColorEditFlags.DisplayHSV | ColorEditFlags.DisplayHex;
    _DataTypeMask       :: ColorEditFlags.Uint8 | ColorEditFlags.Float;
    _PickerMask         :: ColorEditFlags.PickerHueWheel | ColorEditFlags.PickerHueBar;
    _InputMask          :: ColorEditFlags.InputRGB | ColorEditFlags.InputHSV;
}

ComboFlags :: enum_flags s32 {
    None              :: 0;
    PopupAlignLeft    :: 1 << 0;
    HeightSmall       :: 1 << 1;
    HeightRegular     :: 1 << 2;
    HeightLarge       :: 1 << 3;
    HeightLargest     :: 1 << 4;
    NoArrowButton     :: 1 << 5;
    NoPreview         :: 1 << 6;
    HeightMask_       :: ComboFlags.HeightSmall | ComboFlags.HeightRegular | ComboFlags.HeightLarge | ComboFlags.HeightLargest;
}

Cond :: enum s32 {
    None            :: 0;
    Always          :: 1 << 0;
    Once            :: 1 << 1;
    FirstUseEver    :: 1 << 2;
    Appearing       :: 1 << 3;
}

ConfigFlags :: enum_flags s32 {
    None                       :: 0;
    NavEnableKeyboard          :: 1 << 0;
    NavEnableGamepad           :: 1 << 1;
    NavEnableSetMousePos       :: 1 << 2;
    NavNoCaptureKeyboard       :: 1 << 3;
    NoMouse                    :: 1 << 4;
    NoMouseCursorChange        :: 1 << 5;
    DockingEnable              :: 1 << 6;
    ViewportsEnable            :: 1 << 10;
    DpiEnableScaleViewports    :: 1 << 14;
    DpiEnableScaleFonts        :: 1 << 15;
    IsSRGB                     :: 1 << 20;
    IsTouchScreen              :: 1 << 21;
}

ContextHookType :: enum s32 {
    NewFramePre     :: 0;
    NewFramePost    :: 1;
    EndFramePre     :: 2;
    EndFramePost    :: 3;
    RenderPre       :: 4;
    RenderPost      :: 5;
    Shutdown        :: 6;
}

DataAuthority :: enum s32 {
    Auto        :: 0;
    DockNode    :: 1;
    Window      :: 2;
}

DataType :: enum s32 {
    S8        :: 0;
    U8        :: 1;
    S16       :: 2;
    U16       :: 3;
    S32       :: 4;
    U32       :: 5;
    S64       :: 6;
    U64       :: 7;
    Float     :: 8;
    Double    :: 9;
    COUNT     :: 10;
}

Dir :: enum s32 {
    None     :: -1;
    Left     :: 0;
    Right    :: 1;
    Up       :: 2;
    Down     :: 3;
    COUNT    :: 4;
}

DockNodeFlags :: enum_flags s32 {
    None                      :: 0;
    KeepAliveOnly             :: 1 << 0;
    NoDockingInCentralNode    :: 1 << 2;
    PassthruCentralNode       :: 1 << 3;
    NoSplit                   :: 1 << 4;
    NoResize                  :: 1 << 5;
    AutoHideTabBar            :: 1 << 6;
}

DockNodeState :: enum s32 {
    Unknown                                      :: 0;
    HostWindowHiddenBecauseSingleWindow          :: 1;
    HostWindowHiddenBecauseWindowsAreResizing    :: 2;
    HostWindowVisible                            :: 3;
}

DragDropFlags :: enum_flags s32 {
    None                        :: 0;
    SourceNoPreviewTooltip      :: 1 << 0;
    SourceNoDisableHover        :: 1 << 1;
    SourceNoHoldToOpenOthers    :: 1 << 2;
    SourceAllowNullID           :: 1 << 3;
    SourceExtern                :: 1 << 4;
    SourceAutoExpirePayload     :: 1 << 5;
    AcceptBeforeDelivery        :: 1 << 10;
    AcceptNoDrawDefaultRect     :: 1 << 11;
    AcceptNoPreviewTooltip      :: 1 << 12;
    AcceptPeekOnly              :: DragDropFlags.AcceptBeforeDelivery | DragDropFlags.AcceptNoDrawDefaultRect;
}

FocusedFlags :: enum_flags s32 {
    None                   :: 0;
    ChildWindows           :: 1 << 0;
    RootWindow             :: 1 << 1;
    AnyWindow              :: 1 << 2;
    RootAndChildWindows    :: FocusedFlags.RootWindow | FocusedFlags.ChildWindows;
}

HoveredFlags :: enum_flags s32 {
    None                            :: 0;
    ChildWindows                    :: 1 << 0;
    RootWindow                      :: 1 << 1;
    AnyWindow                       :: 1 << 2;
    AllowWhenBlockedByPopup         :: 1 << 3;
    AllowWhenBlockedByActiveItem    :: 1 << 5;
    AllowWhenOverlapped             :: 1 << 6;
    AllowWhenDisabled               :: 1 << 7;
    RectOnly                        :: HoveredFlags.AllowWhenBlockedByPopup | HoveredFlags.AllowWhenBlockedByActiveItem | HoveredFlags.AllowWhenOverlapped;
    RootAndChildWindows             :: HoveredFlags.RootWindow | HoveredFlags.ChildWindows;
}

InputReadMode :: enum s32 {
    Down          :: 0;
    Pressed       :: 1;
    Released      :: 2;
    Repeat        :: 3;
    RepeatSlow    :: 4;
    RepeatFast    :: 5;
}

InputSource :: enum s32 {
    None           :: 0;
    Mouse          :: 1;
    Nav            :: 2;
    NavKeyboard    :: 3;
    NavGamepad     :: 4;
    COUNT          :: 5;
}

InputTextFlags :: enum_flags s32 {
    None                   :: 0;
    CharsDecimal           :: 1 << 0;
    CharsHexadecimal       :: 1 << 1;
    CharsUppercase         :: 1 << 2;
    CharsNoBlank           :: 1 << 3;
    AutoSelectAll          :: 1 << 4;
    EnterReturnsTrue       :: 1 << 5;
    CallbackCompletion     :: 1 << 6;
    CallbackHistory        :: 1 << 7;
    CallbackAlways         :: 1 << 8;
    CallbackCharFilter     :: 1 << 9;
    AllowTabInput          :: 1 << 10;
    CtrlEnterForNewLine    :: 1 << 11;
    NoHorizontalScroll     :: 1 << 12;
    AlwaysInsertMode       :: 1 << 13;
    ReadOnly               :: 1 << 14;
    Password               :: 1 << 15;
    NoUndoRedo             :: 1 << 16;
    CharsScientific        :: 1 << 17;
    CallbackResize         :: 1 << 18;
    CallbackEdit           :: 1 << 19;
    Multiline              :: 1 << 20;
    NoMarkEdited           :: 1 << 21;
}

ItemFlags :: enum_flags s32 {
    None                        :: 0;
    NoTabStop                   :: 1 << 0;
    ButtonRepeat                :: 1 << 1;
    Disabled                    :: 1 << 2;
    NoNav                       :: 1 << 3;
    NoNavDefaultFocus           :: 1 << 4;
    SelectableDontClosePopup    :: 1 << 5;
    MixedValue                  :: 1 << 6;
    ReadOnly                    :: 1 << 7;
    Default_                    :: 0;
}

ItemStatusFlags :: enum_flags s32 {
    None                :: 0;
    HoveredRect         :: 1 << 0;
    HasDisplayRect      :: 1 << 1;
    Edited              :: 1 << 2;
    ToggledSelection    :: 1 << 3;
    ToggledOpen         :: 1 << 4;
    HasDeactivated      :: 1 << 5;
    Deactivated         :: 1 << 6;
}

KeyModFlags :: enum_flags s32 {
    None     :: 0;
    Ctrl     :: 1 << 0;
    Shift    :: 1 << 1;
    Alt      :: 1 << 2;
    Super    :: 1 << 3;
}

Key :: enum s32 {
    Tab            :: 0;
    LeftArrow      :: 1;
    RightArrow     :: 2;
    UpArrow        :: 3;
    DownArrow      :: 4;
    PageUp         :: 5;
    PageDown       :: 6;
    Home           :: 7;
    End            :: 8;
    Insert         :: 9;
    Delete         :: 10;
    Backspace      :: 11;
    Space          :: 12;
    Enter          :: 13;
    Escape         :: 14;
    KeyPadEnter    :: 15;
    A              :: 16;
    C              :: 17;
    V              :: 18;
    X              :: 19;
    Y              :: 20;
    Z              :: 21;
    COUNT          :: 22;
}

LayoutType :: enum s32 {
    Horizontal    :: 0;
    Vertical      :: 1;
}

LogType :: enum s32 {
    None         :: 0;
    TTY          :: 1;
    File         :: 2;
    Buffer       :: 3;
    Clipboard    :: 4;
}

MouseButton :: enum s32 {
    Left      :: 0;
    Right     :: 1;
    Middle    :: 2;
    COUNT     :: 5;
}

MouseCursor :: enum s32 {
    None          :: -1;
    Arrow         :: 0;
    TextInput     :: 1;
    ResizeAll     :: 2;
    ResizeNS      :: 3;
    ResizeEW      :: 4;
    ResizeNESW    :: 5;
    ResizeNWSE    :: 6;
    Hand          :: 7;
    NotAllowed    :: 8;
    COUNT         :: 9;
}

NavDirSourceFlags :: enum_flags s32 {
    None         :: 0;
    Keyboard     :: 1 << 0;
    PadDPad      :: 1 << 1;
    PadLStick    :: 1 << 2;
}

NavForward :: enum s32 {
    None             :: 0;
    ForwardQueued    :: 1;
    ForwardActive    :: 2;
}

NavHighlightFlags :: enum_flags s32 {
    None           :: 0;
    TypeDefault    :: 1 << 0;
    TypeThin       :: 1 << 1;
    AlwaysDraw     :: 1 << 2;
    NoRounding     :: 1 << 3;
}

NavInput :: enum s32 {
    Activate          :: 0;
    Cancel            :: 1;
    Input             :: 2;
    Menu              :: 3;
    DpadLeft          :: 4;
    DpadRight         :: 5;
    DpadUp            :: 6;
    DpadDown          :: 7;
    LStickLeft        :: 8;
    LStickRight       :: 9;
    LStickUp          :: 10;
    LStickDown        :: 11;
    FocusPrev         :: 12;
    FocusNext         :: 13;
    TweakSlow         :: 14;
    TweakFast         :: 15;
    KeyMenu_          :: 16;
    KeyLeft_          :: 17;
    KeyRight_         :: 18;
    KeyUp_            :: 19;
    KeyDown_          :: 20;
    COUNT             :: 21;
    InternalStart_    :: NavInput.KeyMenu_;
}

NavLayer :: enum s32 {
    Main     :: 0;
    Menu     :: 1;
    COUNT    :: 2;
}

NavMoveFlags :: enum_flags s32 {
    None                   :: 0;
    LoopX                  :: 1 << 0;
    LoopY                  :: 1 << 1;
    WrapX                  :: 1 << 2;
    WrapY                  :: 1 << 3;
    AllowCurrentNavId      :: 1 << 4;
    AlsoScoreVisibleSet    :: 1 << 5;
    ScrollToEdge           :: 1 << 6;
}

NextItemDataFlags :: enum_flags s32 {
    None        :: 0;
    HasWidth    :: 1 << 0;
    HasOpen     :: 1 << 1;
}

NextWindowDataFlags :: enum_flags s32 {
    None                 :: 0;
    HasPos               :: 1 << 0;
    HasSize              :: 1 << 1;
    HasContentSize       :: 1 << 2;
    HasCollapsed         :: 1 << 3;
    HasSizeConstraint    :: 1 << 4;
    HasFocus             :: 1 << 5;
    HasBgAlpha           :: 1 << 6;
    HasScroll            :: 1 << 7;
    HasViewport          :: 1 << 8;
    HasDock              :: 1 << 9;
    HasWindowClass       :: 1 << 10;
}

OldColumnFlags :: enum_flags s32 {
    None                      :: 0;
    NoBorder                  :: 1 << 0;
    NoResize                  :: 1 << 1;
    NoPreserveWidths          :: 1 << 2;
    NoForceWithinWindow       :: 1 << 3;
    GrowParentContentsSize    :: 1 << 4;
}

PlotType :: enum s32 {
    Lines        :: 0;
    Histogram    :: 1;
}

PopupFlags :: enum_flags s32 {
    None                       :: 0;
    MouseButtonLeft            :: 0;
    MouseButtonRight           :: 1;
    MouseButtonMiddle          :: 2;
    MouseButtonMask_           :: 0x1F;
    MouseButtonDefault_        :: 1;
    NoOpenOverExistingPopup    :: 1 << 5;
    NoOpenOverItems            :: 1 << 6;
    AnyPopupId                 :: 1 << 7;
    AnyPopupLevel              :: 1 << 8;
    AnyPopup                   :: PopupFlags.AnyPopupId | PopupFlags.AnyPopupLevel;
}

PopupPositionPolicy :: enum s32 {
    Default     :: 0;
    ComboBox    :: 1;
    Tooltip     :: 2;
}

SelectableFlags :: enum_flags s32 {
    None                :: 0;
    DontClosePopups     :: 1 << 0;
    SpanAllColumns      :: 1 << 1;
    AllowDoubleClick    :: 1 << 2;
    Disabled            :: 1 << 3;
    AllowItemOverlap    :: 1 << 4;
}

SeparatorFlags :: enum_flags s32 {
    None              :: 0;
    Horizontal        :: 1 << 0;
    Vertical          :: 1 << 1;
    SpanAllColumns    :: 1 << 2;
}

SliderFlags :: enum_flags s32 {
    None               :: 0;
    AlwaysClamp        :: 1 << 4;
    Logarithmic        :: 1 << 5;
    NoRoundToFormat    :: 1 << 6;
    NoInput            :: 1 << 7;
    InvalidMask_       :: 0x7000000F;
}

SortDirection :: enum s32 {
    None          :: 0;
    Ascending     :: 1;
    Descending    :: 2;
}

StyleVar :: enum s32 {
    Alpha                  :: 0;
    WindowPadding          :: 1;
    WindowRounding         :: 2;
    WindowBorderSize       :: 3;
    WindowMinSize          :: 4;
    WindowTitleAlign       :: 5;
    ChildRounding          :: 6;
    ChildBorderSize        :: 7;
    PopupRounding          :: 8;
    PopupBorderSize        :: 9;
    FramePadding           :: 10;
    FrameRounding          :: 11;
    FrameBorderSize        :: 12;
    ItemSpacing            :: 13;
    ItemInnerSpacing       :: 14;
    IndentSpacing          :: 15;
    CellPadding            :: 16;
    ScrollbarSize          :: 17;
    ScrollbarRounding      :: 18;
    GrabMinSize            :: 19;
    GrabRounding           :: 20;
    TabRounding            :: 21;
    ButtonTextAlign        :: 22;
    SelectableTextAlign    :: 23;
    COUNT                  :: 24;
}

TabBarFlags :: enum_flags s32 {
    None                            :: 0;
    Reorderable                     :: 1 << 0;
    AutoSelectNewTabs               :: 1 << 1;
    TabListPopupButton              :: 1 << 2;
    NoCloseWithMiddleMouseButton    :: 1 << 3;
    NoTabListScrollingButtons       :: 1 << 4;
    NoTooltip                       :: 1 << 5;
    FittingPolicyResizeDown         :: 1 << 6;
    FittingPolicyScroll             :: 1 << 7;
    FittingPolicyMask_              :: TabBarFlags.FittingPolicyResizeDown | TabBarFlags.FittingPolicyScroll;
    FittingPolicyDefault_           :: TabBarFlags.FittingPolicyResizeDown;
}

TabItemFlags :: enum_flags s32 {
    None                            :: 0;
    UnsavedDocument                 :: 1 << 0;
    SetSelected                     :: 1 << 1;
    NoCloseWithMiddleMouseButton    :: 1 << 2;
    NoPushId                        :: 1 << 3;
    NoTooltip                       :: 1 << 4;
    NoReorder                       :: 1 << 5;
    Leading                         :: 1 << 6;
    Trailing                        :: 1 << 7;
}

TableBgTarget :: enum s32 {
    None      :: 0;
    RowBg0    :: 1;
    RowBg1    :: 2;
    CellBg    :: 3;
}

TableColumnFlags :: enum_flags s32 {
    None                    :: 0;
    DefaultHide             :: 1 << 0;
    DefaultSort             :: 1 << 1;
    WidthStretch            :: 1 << 2;
    WidthFixed              :: 1 << 3;
    WidthAutoResize         :: 1 << 4;
    NoResize                :: 1 << 5;
    NoReorder               :: 1 << 6;
    NoHide                  :: 1 << 7;
    NoClip                  :: 1 << 8;
    NoSort                  :: 1 << 9;
    NoSortAscending         :: 1 << 10;
    NoSortDescending        :: 1 << 11;
    NoHeaderWidth           :: 1 << 12;
    PreferSortAscending     :: 1 << 13;
    PreferSortDescending    :: 1 << 14;
    IndentEnable            :: 1 << 15;
    IndentDisable           :: 1 << 16;
    IsEnabled               :: 1 << 20;
    IsVisible               :: 1 << 21;
    IsSorted                :: 1 << 22;
    IsHovered               :: 1 << 23;
    WidthMask_              :: TableColumnFlags.WidthStretch | TableColumnFlags.WidthFixed | TableColumnFlags.WidthAutoResize;
    IndentMask_             :: TableColumnFlags.IndentEnable | TableColumnFlags.IndentDisable;
    StatusMask_             :: TableColumnFlags.IsEnabled | TableColumnFlags.IsVisible | TableColumnFlags.IsSorted | TableColumnFlags.IsHovered;
    NoDirectResize_         :: 1 << 30;
}

TableFlags :: enum_flags s32 {
    None                          :: 0;
    Resizable                     :: 1 << 0;
    Reorderable                   :: 1 << 1;
    Hideable                      :: 1 << 2;
    Sortable                      :: 1 << 3;
    NoSavedSettings               :: 1 << 4;
    ContextMenuInBody             :: 1 << 5;
    RowBg                         :: 1 << 6;
    BordersInnerH                 :: 1 << 7;
    BordersOuterH                 :: 1 << 8;
    BordersInnerV                 :: 1 << 9;
    BordersOuterV                 :: 1 << 10;
    BordersH                      :: TableFlags.BordersInnerH | TableFlags.BordersOuterH;
    BordersV                      :: TableFlags.BordersInnerV | TableFlags.BordersOuterV;
    BordersInner                  :: TableFlags.BordersInnerV | TableFlags.BordersInnerH;
    BordersOuter                  :: TableFlags.BordersOuterV | TableFlags.BordersOuterH;
    Borders                       :: TableFlags.BordersInner | TableFlags.BordersOuter;
    NoBordersInBody               :: 1 << 11;
    NoBordersInBodyUntilResize    :: 1 << 12;
    ColumnsWidthStretch           :: 1 << 13;
    ColumnsWidthFixed             :: 1 << 14;
    SameWidths                    :: 1 << 15;
    NoHeadersWidth                :: 1 << 16;
    NoHostExtendY                 :: 1 << 17;
    NoKeepColumnsVisible          :: 1 << 18;
    PreciseWidths                 :: 1 << 19;
    NoClip                        :: 1 << 20;
    PadOuterX                     :: 1 << 21;
    NoPadOuterX                   :: 1 << 22;
    NoPadInnerX                   :: 1 << 23;
    ScrollX                       :: 1 << 24;
    ScrollY                       :: 1 << 25;
    SortMulti                     :: 1 << 26;
    SortTristate                  :: 1 << 27;
}

TableRowFlags :: enum_flags s32 {
    None       :: 0;
    Headers    :: 1 << 0;
}

TextFlags :: enum_flags s32 {
    None                          :: 0;
    NoWidthForLargeClippedText    :: 1 << 0;
}

TooltipFlags :: enum_flags s32 {
    None                       :: 0;
    OverridePreviousTooltip    :: 1 << 0;
}

TreeNodeFlags :: enum_flags s32 {
    None                    :: 0;
    Selected                :: 1 << 0;
    Framed                  :: 1 << 1;
    AllowItemOverlap        :: 1 << 2;
    NoTreePushOnOpen        :: 1 << 3;
    NoAutoOpenOnLog         :: 1 << 4;
    DefaultOpen             :: 1 << 5;
    OpenOnDoubleClick       :: 1 << 6;
    OpenOnArrow             :: 1 << 7;
    Leaf                    :: 1 << 8;
    Bullet                  :: 1 << 9;
    FramePadding            :: 1 << 10;
    SpanAvailWidth          :: 1 << 11;
    SpanFullWidth           :: 1 << 12;
    NavLeftJumpsBackHere    :: 1 << 13;
    CollapsingHeader        :: TreeNodeFlags.Framed | TreeNodeFlags.NoTreePushOnOpen | TreeNodeFlags.NoAutoOpenOnLog;
}

ViewportFlags :: enum_flags s32 {
    None                   :: 0;
    NoDecoration           :: 1 << 0;
    NoTaskBarIcon          :: 1 << 1;
    NoFocusOnAppearing     :: 1 << 2;
    NoFocusOnClick         :: 1 << 3;
    NoInputs               :: 1 << 4;
    NoRendererClear        :: 1 << 5;
    TopMost                :: 1 << 6;
    Minimized              :: 1 << 7;
    NoAutoMerge            :: 1 << 8;
    CanHostOtherWindows    :: 1 << 9;
}

WindowFlags :: enum_flags s32 {
    None                         :: 0;
    NoTitleBar                   :: 1 << 0;
    NoResize                     :: 1 << 1;
    NoMove                       :: 1 << 2;
    NoScrollbar                  :: 1 << 3;
    NoScrollWithMouse            :: 1 << 4;
    NoCollapse                   :: 1 << 5;
    AlwaysAutoResize             :: 1 << 6;
    NoBackground                 :: 1 << 7;
    NoSavedSettings              :: 1 << 8;
    NoMouseInputs                :: 1 << 9;
    MenuBar                      :: 1 << 10;
    HorizontalScrollbar          :: 1 << 11;
    NoFocusOnAppearing           :: 1 << 12;
    NoBringToFrontOnFocus        :: 1 << 13;
    AlwaysVerticalScrollbar      :: 1 << 14;
    AlwaysHorizontalScrollbar    :: 1<< 15;
    AlwaysUseWindowPadding       :: 1 << 16;
    NoNavInputs                  :: 1 << 18;
    NoNavFocus                   :: 1 << 19;
    UnsavedDocument              :: 1 << 20;
    NoDocking                    :: 1 << 21;
    NoNav                        :: WindowFlags.NoNavInputs | WindowFlags.NoNavFocus;
    NoDecoration                 :: WindowFlags.NoTitleBar | WindowFlags.NoResize | WindowFlags.NoScrollbar | WindowFlags.NoCollapse;
    NoInputs                     :: WindowFlags.NoMouseInputs | WindowFlags.NoNavInputs | WindowFlags.NoNavFocus;
    NavFlattened                 :: 1 << 23;
    ChildWindow                  :: 1 << 24;
    Tooltip                      :: 1 << 25;
    Popup                        :: 1 << 26;
    Modal                        :: 1 << 27;
    ChildMenu                    :: 1 << 28;
    DockNodeHost                 :: 1 << 29;
}


//
// section: FUNCTIONS
//

AcceptDragDropPayload                            :: (type: *u8, flags: DragDropFlags = .None) -> *Payload #foreign imgui_lib "?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z";
ActivateItem                                     :: (id: ID) #foreign imgui_lib "?ActivateItem@ImGui@@YAXI@Z";
AddContextHook                                   :: (ctx: *Context, hook: *ContextHook) #foreign imgui_lib "?AddContextHook@ImGui@@YAXPEAUImGuiContext@@PEBUImGuiContextHook@@@Z";
AlignTextToFramePadding                          :: () #foreign imgui_lib "?AlignTextToFramePadding@ImGui@@YAXXZ";
ArrowButton                                      :: (str_id: *u8, dir: Dir) -> bool #foreign imgui_lib "?ArrowButton@ImGui@@YA_NPEBDH@Z";
ArrowButtonEx                                    :: (str_id: *u8, dir: Dir, size_arg: ImVec2, flags: ButtonFlags = .None) -> bool #foreign imgui_lib "?ArrowButtonEx@ImGui@@YA_NPEBDHUImVec2@@H@Z";
Begin                                            :: (name: *u8, p_open: *bool = null, flags: WindowFlags = .None) -> bool #foreign imgui_lib "?Begin@ImGui@@YA_NPEBDPEA_NH@Z";
BeginChild                                       :: (str_id: *u8, size: ImVec2 = ImVec2.{0,0}, border: bool = false, flags: WindowFlags = .None) -> bool {
    _internal_BeginChild :: (str_id: *u8, size: *ImVec2, border: bool, flags: WindowFlags) -> bool #foreign imgui_lib "?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z";
    return _internal_BeginChild(str_id, *size, border, flags);
}
BeginChild                                       :: (id: ID, size: ImVec2 = ImVec2.{0,0}, border: bool = false, flags: WindowFlags = .None) -> bool {
    _internal_BeginChild :: (id: ID, size: *ImVec2, border: bool, flags: WindowFlags) -> bool #foreign imgui_lib "?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z";
    return _internal_BeginChild(id, *size, border, flags);
}
BeginChildEx                                     :: (name: *u8, id: ID, size_arg: ImVec2, border: bool, flags: WindowFlags) -> bool {
    _internal_BeginChildEx :: (name: *u8, id: ID, size_arg: *ImVec2, border: bool, flags: WindowFlags) -> bool #foreign imgui_lib "?BeginChildEx@ImGui@@YA_NPEBDIAEBUImVec2@@_NH@Z";
    return _internal_BeginChildEx(name, id, *size_arg, border, flags);
}
BeginChildFrame                                  :: (id: ID, size: ImVec2, flags: WindowFlags = .None) -> bool {
    _internal_BeginChildFrame :: (id: ID, size: *ImVec2, flags: WindowFlags) -> bool #foreign imgui_lib "?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z";
    return _internal_BeginChildFrame(id, *size, flags);
}
BeginColumns                                     :: (str_id: *u8, count: s32, flags: OldColumnFlags = .None) #foreign imgui_lib "?BeginColumns@ImGui@@YAXPEBDHH@Z";
BeginCombo                                       :: (label: *u8, preview_value: *u8, flags: ComboFlags = .None) -> bool #foreign imgui_lib "?BeginCombo@ImGui@@YA_NPEBD0H@Z";
BeginDockableDragDropSource                      :: (window: *Window) #foreign imgui_lib "?BeginDockableDragDropSource@ImGui@@YAXPEAUImGuiWindow@@@Z";
BeginDockableDragDropTarget                      :: (window: *Window) #foreign imgui_lib "?BeginDockableDragDropTarget@ImGui@@YAXPEAUImGuiWindow@@@Z";
BeginDocked                                      :: (window: *Window, p_open: *bool) #foreign imgui_lib "?BeginDocked@ImGui@@YAXPEAUImGuiWindow@@PEA_N@Z";
BeginDragDropSource                              :: (flags: DragDropFlags = .None) -> bool #foreign imgui_lib "?BeginDragDropSource@ImGui@@YA_NH@Z";
BeginDragDropTarget                              :: () -> bool #foreign imgui_lib "?BeginDragDropTarget@ImGui@@YA_NXZ";
BeginDragDropTargetCustom                        :: (bb: ImRect, id: ID) -> bool {
    _internal_BeginDragDropTargetCustom :: (bb: *ImRect, id: ID) -> bool #foreign imgui_lib "?BeginDragDropTargetCustom@ImGui@@YA_NAEBUImRect@@I@Z";
    return _internal_BeginDragDropTargetCustom(*bb, id);
}
BeginGroup                                       :: () #foreign imgui_lib "?BeginGroup@ImGui@@YAXXZ";
BeginMainMenuBar                                 :: () -> bool #foreign imgui_lib "?BeginMainMenuBar@ImGui@@YA_NXZ";
BeginMenu                                        :: (label: *u8, enabled: bool = true) -> bool #foreign imgui_lib "?BeginMenu@ImGui@@YA_NPEBD_N@Z";
BeginMenuBar                                     :: () -> bool #foreign imgui_lib "?BeginMenuBar@ImGui@@YA_NXZ";
BeginPopup                                       :: (str_id: *u8, flags: WindowFlags = .None) -> bool #foreign imgui_lib "?BeginPopup@ImGui@@YA_NPEBDH@Z";
BeginPopupContextItem                            :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui_lib "?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z";
BeginPopupContextVoid                            :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui_lib "?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z";
BeginPopupContextWindow                          :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui_lib "?BeginPopupContextWindow@ImGui@@YA_NPEBDH@Z";
BeginPopupEx                                     :: (id: ID, extra_flags: WindowFlags) -> bool #foreign imgui_lib "?BeginPopupEx@ImGui@@YA_NIH@Z";
BeginPopupModal                                  :: (name: *u8, p_open: *bool = null, flags: WindowFlags = .None) -> bool #foreign imgui_lib "?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z";
BeginTabBar                                      :: (str_id: *u8, flags: TabBarFlags = .None) -> bool #foreign imgui_lib "?BeginTabBar@ImGui@@YA_NPEBDH@Z";
BeginTabBarEx                                    :: (tab_bar: *TabBar, bb: ImRect, flags: TabBarFlags, dock_node: *DockNode) -> bool {
    _internal_BeginTabBarEx :: (tab_bar: *TabBar, bb: *ImRect, flags: TabBarFlags, dock_node: *DockNode) -> bool #foreign imgui_lib "?BeginTabBarEx@ImGui@@YA_NPEAUImGuiTabBar@@AEBUImRect@@HPEAUImGuiDockNode@@@Z";
    return _internal_BeginTabBarEx(tab_bar, *bb, flags, dock_node);
}
BeginTabItem                                     :: (label: *u8, p_open: *bool = null, flags: TabItemFlags = .None) -> bool #foreign imgui_lib "?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z";
BeginTable                                       :: (str_id: *u8, columns_count: s32, flags: TableFlags = .None, outer_size: ImVec2 = ImVec2.{0,0}, inner_width: float = 0.0) -> bool {
    _internal_BeginTable :: (str_id: *u8, columns_count: s32, flags: TableFlags, outer_size: *ImVec2, inner_width: float) -> bool #foreign imgui_lib "?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z";
    return _internal_BeginTable(str_id, columns_count, flags, *outer_size, inner_width);
}
BeginTableEx                                     :: (name: *u8, id: ID, columns_count: s32, flags: TableFlags = .None, outer_size: ImVec2 = ImVec2.{0,0}, inner_width: float = 0.0) -> bool {
    _internal_BeginTableEx :: (name: *u8, id: ID, columns_count: s32, flags: TableFlags, outer_size: *ImVec2, inner_width: float) -> bool #foreign imgui_lib "?BeginTableEx@ImGui@@YA_NPEBDIHHAEBUImVec2@@M@Z";
    return _internal_BeginTableEx(name, id, columns_count, flags, *outer_size, inner_width);
}
BeginTooltip                                     :: () #foreign imgui_lib "?BeginTooltip@ImGui@@YAXXZ";
BeginTooltipEx                                   :: (extra_flags: WindowFlags, tooltip_flags: TooltipFlags) #foreign imgui_lib "?BeginTooltipEx@ImGui@@YAXHH@Z";
BringWindowToDisplayBack                         :: (window: *Window) #foreign imgui_lib "?BringWindowToDisplayBack@ImGui@@YAXPEAUImGuiWindow@@@Z";
BringWindowToDisplayFront                        :: (window: *Window) #foreign imgui_lib "?BringWindowToDisplayFront@ImGui@@YAXPEAUImGuiWindow@@@Z";
BringWindowToFocusFront                          :: (window: *Window) #foreign imgui_lib "?BringWindowToFocusFront@ImGui@@YAXPEAUImGuiWindow@@@Z";
Bullet                                           :: () #foreign imgui_lib "?Bullet@ImGui@@YAXXZ";
BulletText                                       :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?BulletText@ImGui@@YAXPEBDZZ";
Button                                           :: (label: *u8, size: ImVec2 = ImVec2.{0,0}) -> bool {
    _internal_Button :: (label: *u8, size: *ImVec2) -> bool #foreign imgui_lib "?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z";
    return _internal_Button(label, *size);
}
ButtonBehavior                                   :: (bb: ImRect, id: ID, out_hovered: *bool, out_held: *bool, flags: ButtonFlags = .None) -> bool {
    _internal_ButtonBehavior :: (bb: *ImRect, id: ID, out_hovered: *bool, out_held: *bool, flags: ButtonFlags) -> bool #foreign imgui_lib "?ButtonBehavior@ImGui@@YA_NAEBUImRect@@IPEA_N1H@Z";
    return _internal_ButtonBehavior(*bb, id, out_hovered, out_held, flags);
}
ButtonEx                                         :: (label: *u8, size_arg: ImVec2 = ImVec2.{0,0}, flags: ButtonFlags = .None) -> bool {
    _internal_ButtonEx :: (label: *u8, size_arg: *ImVec2, flags: ButtonFlags) -> bool #foreign imgui_lib "?ButtonEx@ImGui@@YA_NPEBDAEBUImVec2@@H@Z";
    return _internal_ButtonEx(label, *size_arg, flags);
}
CalcItemWidth                                    :: () -> float #foreign imgui_lib "?CalcItemWidth@ImGui@@YAMXZ";
CalcListClipping                                 :: (items_count: s32, items_height: float, out_items_display_start: *s32, out_items_display_end: *s32) #foreign imgui_lib "?CalcListClipping@ImGui@@YAXHMPEAH0@Z";
CalcTypematicRepeatAmount                        :: (t0: float, t1: float, repeat_delay: float, repeat_rate: float) -> s32 #foreign imgui_lib "?CalcTypematicRepeatAmount@ImGui@@YAHMMMM@Z";
CalcWrapWidthForPos                              :: (pos: ImVec2, wrap_pos_x: float) -> float {
    _internal_CalcWrapWidthForPos :: (pos: *ImVec2, wrap_pos_x: float) -> float #foreign imgui_lib "?CalcWrapWidthForPos@ImGui@@YAMAEBUImVec2@@M@Z";
    return _internal_CalcWrapWidthForPos(*pos, wrap_pos_x);
}
CaptureKeyboardFromApp                           :: (want_capture_keyboard_value: bool = true) #foreign imgui_lib "?CaptureKeyboardFromApp@ImGui@@YAX_N@Z";
CaptureMouseFromApp                              :: (want_capture_mouse_value: bool = true) #foreign imgui_lib "?CaptureMouseFromApp@ImGui@@YAX_N@Z";
Checkbox                                         :: (label: *u8, v: *bool) -> bool #foreign imgui_lib "?Checkbox@ImGui@@YA_NPEBDPEA_N@Z";
CheckboxFlags                                    :: (label: *u8, flags: *s32, flags_value: s32) -> bool #foreign imgui_lib "?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z";
CheckboxFlags                                    :: (label: *u8, flags: *u32, flags_value: u32) -> bool #foreign imgui_lib "?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z";
ClearActiveID                                    :: () #foreign imgui_lib "?ClearActiveID@ImGui@@YAXXZ";
ClearDragDrop                                    :: () #foreign imgui_lib "?ClearDragDrop@ImGui@@YAXXZ";
ClearIniSettings                                 :: () #foreign imgui_lib "?ClearIniSettings@ImGui@@YAXXZ";
CloseButton                                      :: (id: ID, pos: ImVec2) -> bool {
    _internal_CloseButton :: (id: ID, pos: *ImVec2) -> bool #foreign imgui_lib "?CloseButton@ImGui@@YA_NIAEBUImVec2@@@Z";
    return _internal_CloseButton(id, *pos);
}
CloseCurrentPopup                                :: () #foreign imgui_lib "?CloseCurrentPopup@ImGui@@YAXXZ";
ClosePopupToLevel                                :: (remaining: s32, restore_focus_to_window_under_popup: bool) #foreign imgui_lib "?ClosePopupToLevel@ImGui@@YAXH_N@Z";
ClosePopupsOverWindow                            :: (ref_window: *Window, restore_focus_to_window_under_popup: bool) #foreign imgui_lib "?ClosePopupsOverWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z";
CollapseButton                                   :: (id: ID, pos: ImVec2, dock_node: *DockNode) -> bool {
    _internal_CollapseButton :: (id: ID, pos: *ImVec2, dock_node: *DockNode) -> bool #foreign imgui_lib "?CollapseButton@ImGui@@YA_NIAEBUImVec2@@PEAUImGuiDockNode@@@Z";
    return _internal_CollapseButton(id, *pos, dock_node);
}
CollapsingHeader                                 :: (label: *u8, flags: TreeNodeFlags = .None) -> bool #foreign imgui_lib "?CollapsingHeader@ImGui@@YA_NPEBDH@Z";
CollapsingHeader                                 :: (label: *u8, p_open: *bool, flags: TreeNodeFlags = .None) -> bool #foreign imgui_lib "?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z";
ColorButton                                      :: (desc_id: *u8, col: ImVec4, flags: ColorEditFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
    _internal_ColorButton :: (desc_id: *u8, col: *ImVec4, flags: ColorEditFlags, size: ImVec2) -> bool #foreign imgui_lib "?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z";
    return _internal_ColorButton(desc_id, *col, flags, size);
}
ColorConvertFloat4ToU32                          :: (in: ImVec4) -> u32 {
    _internal_ColorConvertFloat4ToU32 :: (in: *ImVec4) -> u32 #foreign imgui_lib "?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z";
    return _internal_ColorConvertFloat4ToU32(*in);
}
ColorConvertHSVtoRGB                             :: (h: float, s: float, v: float, out_r: *float, out_g: *float, out_b: *float) #foreign imgui_lib "?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z";
ColorConvertRGBtoHSV                             :: (r: float, g: float, b: float, out_h: *float, out_s: *float, out_v: *float) #foreign imgui_lib "?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z";
ColorEdit3                                       :: (label: *u8, col: [3]float, flags: ColorEditFlags = .None) -> bool #foreign imgui_lib "?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z";
ColorEdit4                                       :: (label: *u8, col: [4]float, flags: ColorEditFlags = .None) -> bool #foreign imgui_lib "?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z";
ColorEditOptionsPopup                            :: (col: *float, flags: ColorEditFlags) #foreign imgui_lib "?ColorEditOptionsPopup@ImGui@@YAXPEBMH@Z";
ColorPicker3                                     :: (label: *u8, col: [3]float, flags: ColorEditFlags = .None) -> bool #foreign imgui_lib "?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z";
ColorPicker4                                     :: (label: *u8, col: [4]float, flags: ColorEditFlags = .None, ref_col: *float = null) -> bool #foreign imgui_lib "?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z";
ColorPickerOptionsPopup                          :: (ref_col: *float, flags: ColorEditFlags) #foreign imgui_lib "?ColorPickerOptionsPopup@ImGui@@YAXPEBMH@Z";
ColorTooltip                                     :: (text: *u8, col: *float, flags: ColorEditFlags) #foreign imgui_lib "?ColorTooltip@ImGui@@YAXPEBDPEBMH@Z";
Columns                                          :: (count: s32 = 1, id: *u8 = null, border: bool = true) #foreign imgui_lib "?Columns@ImGui@@YAXHPEBD_N@Z";
Combo                                            :: (label: *u8, current_item: *s32, items: *[]u8, items_count: s32, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui_lib "?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z";
Combo                                            :: (label: *u8, current_item: *s32, items_separated_by_zeros: *u8, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui_lib "?Combo@ImGui@@YA_NPEBDPEAH0H@Z";
Combo                                            :: (label: *u8, current_item: *s32, items_getter: (data: *void, idx: s32, out_text: **u8) -> bool #c_call, data: *void, items_count: s32, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui_lib "?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z";
CreateContext                                    :: (shared_font_atlas: *ImFontAtlas = null) -> *Context #foreign imgui_lib "?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z";
CreateNewWindowSettings                          :: (name: *u8) -> *WindowSettings #foreign imgui_lib "?CreateNewWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@PEBD@Z";
DataTypeApplyOp                                  :: (data_type: DataType, op: s32, output: *void, arg_1: *void, arg_2: *void) #foreign imgui_lib "?DataTypeApplyOp@ImGui@@YAXHHPEAXPEBX1@Z";
DataTypeApplyOpFromText                          :: (buf: *u8, initial_value_buf: *u8, data_type: DataType, p_data: *void, format: *u8) -> bool #foreign imgui_lib "?DataTypeApplyOpFromText@ImGui@@YA_NPEBD0HPEAX0@Z";
DataTypeClamp                                    :: (data_type: DataType, p_data: *void, p_min: *void, p_max: *void) -> bool #foreign imgui_lib "?DataTypeClamp@ImGui@@YA_NHPEAXPEBX1@Z";
DataTypeCompare                                  :: (data_type: DataType, arg_1: *void, arg_2: *void) -> s32 #foreign imgui_lib "?DataTypeCompare@ImGui@@YAHHPEBX0@Z";
DataTypeFormatString                             :: (buf: *u8, buf_size: s32, data_type: DataType, p_data: *void, format: *u8) -> s32 #foreign imgui_lib "?DataTypeFormatString@ImGui@@YAHPEADHHPEBXPEBD@Z";
DataTypeGetInfo                                  :: (data_type: DataType) -> *DataTypeInfo #foreign imgui_lib "?DataTypeGetInfo@ImGui@@YAPEBUImGuiDataTypeInfo@@H@Z";
DebugCheckVersionAndDataLayout                   :: (version_str: *u8, sz_io: u64, sz_style: u64, sz_vec2: u64, sz_vec4: u64, sz_drawvert: u64, sz_drawidx: u64) -> bool #foreign imgui_lib "?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z";
DebugNodeColumns                                 :: (columns: *OldColumns) #foreign imgui_lib "?DebugNodeColumns@ImGui@@YAXPEAUImGuiOldColumns@@@Z";
DebugNodeDockNode                                :: (node: *DockNode, label: *u8) #foreign imgui_lib "?DebugNodeDockNode@ImGui@@YAXPEAUImGuiDockNode@@PEBD@Z";
DebugNodeDrawCmdShowMeshAndBoundingBox           :: (out_draw_list: *ImDrawList, draw_list: *ImDrawList, draw_cmd: *ImDrawCmd, show_mesh: bool, show_aabb: bool) #foreign imgui_lib "?DebugNodeDrawCmdShowMeshAndBoundingBox@ImGui@@YAXPEAUImDrawList@@PEBU2@PEBUImDrawCmd@@_N3@Z";
DebugNodeDrawList                                :: (window: *Window, viewport: *ViewportP, draw_list: *ImDrawList, label: *u8) #foreign imgui_lib "?DebugNodeDrawList@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiViewportP@@PEBUImDrawList@@PEBD@Z";
DebugNodeStorage                                 :: (storage: *Storage, label: *u8) #foreign imgui_lib "?DebugNodeStorage@ImGui@@YAXPEAUImGuiStorage@@PEBD@Z";
DebugNodeTabBar                                  :: (tab_bar: *TabBar, label: *u8) #foreign imgui_lib "?DebugNodeTabBar@ImGui@@YAXPEAUImGuiTabBar@@PEBD@Z";
DebugNodeTable                                   :: (table: *Table) #foreign imgui_lib "?DebugNodeTable@ImGui@@YAXPEAUImGuiTable@@@Z";
DebugNodeTableSettings                           :: (settings: *TableSettings) #foreign imgui_lib "?DebugNodeTableSettings@ImGui@@YAXPEAUImGuiTableSettings@@@Z";
DebugNodeViewport                                :: (viewport: *ViewportP) #foreign imgui_lib "?DebugNodeViewport@ImGui@@YAXPEAUImGuiViewportP@@@Z";
DebugNodeWindow                                  :: (window: *Window, label: *u8) #foreign imgui_lib "?DebugNodeWindow@ImGui@@YAXPEAUImGuiWindow@@PEBD@Z";
DebugNodeWindowSettings                          :: (settings: *WindowSettings) #foreign imgui_lib "?DebugNodeWindowSettings@ImGui@@YAXPEAUImGuiWindowSettings@@@Z";
DestroyContext                                   :: (ctx: *Context = null) #foreign imgui_lib "?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z";
DestroyPlatformWindow                            :: (viewport: *ViewportP) #foreign imgui_lib "?DestroyPlatformWindow@ImGui@@YAXPEAUImGuiViewportP@@@Z";
DestroyPlatformWindows                           :: () #foreign imgui_lib "?DestroyPlatformWindows@ImGui@@YAXXZ";
DockBuilderAddNode                               :: (node_id: ID = 0, flags: DockNodeFlags = .None) -> ID #foreign imgui_lib "?DockBuilderAddNode@ImGui@@YAIIH@Z";
DockBuilderCopyWindowSettings                    :: (src_name: *u8, dst_name: *u8) #foreign imgui_lib "?DockBuilderCopyWindowSettings@ImGui@@YAXPEBD0@Z";
DockBuilderDockWindow                            :: (window_name: *u8, node_id: ID) #foreign imgui_lib "?DockBuilderDockWindow@ImGui@@YAXPEBDI@Z";
DockBuilderFinish                                :: (node_id: ID) #foreign imgui_lib "?DockBuilderFinish@ImGui@@YAXI@Z";
DockBuilderGetNode                               :: (node_id: ID) -> *DockNode #foreign imgui_lib "?DockBuilderGetNode@ImGui@@YAPEAUImGuiDockNode@@I@Z";
DockBuilderRemoveNode                            :: (node_id: ID) #foreign imgui_lib "?DockBuilderRemoveNode@ImGui@@YAXI@Z";
DockBuilderRemoveNodeChildNodes                  :: (node_id: ID) #foreign imgui_lib "?DockBuilderRemoveNodeChildNodes@ImGui@@YAXI@Z";
DockBuilderRemoveNodeDockedWindows               :: (node_id: ID, clear_settings_refs: bool = true) #foreign imgui_lib "?DockBuilderRemoveNodeDockedWindows@ImGui@@YAXI_N@Z";
DockBuilderSetNodePos                            :: (node_id: ID, pos: ImVec2) #foreign imgui_lib "?DockBuilderSetNodePos@ImGui@@YAXIUImVec2@@@Z";
DockBuilderSetNodeSize                           :: (node_id: ID, size: ImVec2) #foreign imgui_lib "?DockBuilderSetNodeSize@ImGui@@YAXIUImVec2@@@Z";
DockContextCalcDropPosForDocking                 :: (target: *Window, target_node: *DockNode, payload: *Window, split_dir: Dir, split_outer: bool, out_pos: *ImVec2) -> bool #foreign imgui_lib "?DockContextCalcDropPosForDocking@ImGui@@YA_NPEAUImGuiWindow@@PEAUImGuiDockNode@@0H_NPEAUImVec2@@@Z";
DockContextClearNodes                            :: (ctx: *Context, root_id: ID, clear_settings_refs: bool) #foreign imgui_lib "?DockContextClearNodes@ImGui@@YAXPEAUImGuiContext@@I_N@Z";
DockContextGenNodeID                             :: (ctx: *Context) -> ID #foreign imgui_lib "?DockContextGenNodeID@ImGui@@YAIPEAUImGuiContext@@@Z";
DockContextInitialize                            :: (ctx: *Context) #foreign imgui_lib "?DockContextInitialize@ImGui@@YAXPEAUImGuiContext@@@Z";
DockContextQueueDock                             :: (ctx: *Context, target: *Window, target_node: *DockNode, payload: *Window, split_dir: Dir, split_ratio: float, split_outer: bool) #foreign imgui_lib "?DockContextQueueDock@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiWindow@@PEAUImGuiDockNode@@1HM_N@Z";
DockContextQueueUndockNode                       :: (ctx: *Context, node: *DockNode) #foreign imgui_lib "?DockContextQueueUndockNode@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiDockNode@@@Z";
DockContextQueueUndockWindow                     :: (ctx: *Context, window: *Window) #foreign imgui_lib "?DockContextQueueUndockWindow@ImGui@@YAXPEAUImGuiContext@@PEAUImGuiWindow@@@Z";
DockContextRebuildNodes                          :: (ctx: *Context) #foreign imgui_lib "?DockContextRebuildNodes@ImGui@@YAXPEAUImGuiContext@@@Z";
DockContextShutdown                              :: (ctx: *Context) #foreign imgui_lib "?DockContextShutdown@ImGui@@YAXPEAUImGuiContext@@@Z";
DockContextUpdateDocking                         :: (ctx: *Context) #foreign imgui_lib "?DockContextUpdateDocking@ImGui@@YAXPEAUImGuiContext@@@Z";
DockContextUpdateUndocking                       :: (ctx: *Context) #foreign imgui_lib "?DockContextUpdateUndocking@ImGui@@YAXPEAUImGuiContext@@@Z";
DockNodeBeginAmendTabBar                         :: (node: *DockNode) -> bool #foreign imgui_lib "?DockNodeBeginAmendTabBar@ImGui@@YA_NPEAUImGuiDockNode@@@Z";
DockNodeEndAmendTabBar                           :: () #foreign imgui_lib "?DockNodeEndAmendTabBar@ImGui@@YAXXZ";
DockSpace                                        :: (id: ID, size: ImVec2 = ImVec2.{0,0}, flags: DockNodeFlags = .None, window_class: *WindowClass = null) {
    _internal_DockSpace :: (id: ID, size: *ImVec2, flags: DockNodeFlags, window_class: *WindowClass) #foreign imgui_lib "?DockSpace@ImGui@@YAXIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z";
    _internal_DockSpace(id, *size, flags, window_class);
}
DockSpaceOverViewport                            :: (viewport: *Viewport = null, flags: DockNodeFlags = .None, window_class: *WindowClass = null) -> ID #foreign imgui_lib "?DockSpaceOverViewport@ImGui@@YAIPEAUImGuiViewport@@HPEBUImGuiWindowClass@@@Z";
DragBehavior                                     :: (id: ID, data_type: DataType, p_v: *void, v_speed: float, p_min: *void, p_max: *void, format: *u8, flags: SliderFlags) -> bool #foreign imgui_lib "?DragBehavior@ImGui@@YA_NIHPEAXMPEBX1PEBDH@Z";
DragFloat                                        :: (label: *u8, v: *float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z";
DragFloat2                                       :: (label: *u8, v: [2]float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0H@Z";
DragFloat3                                       :: (label: *u8, v: [3]float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0H@Z";
DragFloat4                                       :: (label: *u8, v: [4]float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0H@Z";
DragFloatRange2                                  :: (label: *u8, v_current_min: *float, v_current_max: *float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", format_max: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00H@Z";
DragInt                                          :: (label: *u8, v: *s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z";
DragInt2                                         :: (label: *u8, v: [2]s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragInt2@ImGui@@YA_NPEBDQEAHMHH0H@Z";
DragInt3                                         :: (label: *u8, v: [3]s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragInt3@ImGui@@YA_NPEBDQEAHMHH0H@Z";
DragInt4                                         :: (label: *u8, v: [4]s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragInt4@ImGui@@YA_NPEBDQEAHMHH0H@Z";
DragIntRange2                                    :: (label: *u8, v_current_min: *s32, v_current_max: *s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", format_max: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00H@Z";
DragScalar                                       :: (label: *u8, data_type: DataType, p_data: *void, v_speed: float, p_min: *void = null, p_max: *void = null, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z";
DragScalarN                                      :: (label: *u8, data_type: DataType, p_data: *void, components: s32, v_speed: float, p_min: *void = null, p_max: *void = null, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z";
Dummy                                            :: (size: ImVec2) {
    _internal_Dummy :: (size: *ImVec2) #foreign imgui_lib "?Dummy@ImGui@@YAXAEBUImVec2@@@Z";
    _internal_Dummy(*size);
}
End                                              :: () #foreign imgui_lib "?End@ImGui@@YAXXZ";
EndChild                                         :: () #foreign imgui_lib "?EndChild@ImGui@@YAXXZ";
EndChildFrame                                    :: () #foreign imgui_lib "?EndChildFrame@ImGui@@YAXXZ";
EndColumns                                       :: () #foreign imgui_lib "?EndColumns@ImGui@@YAXXZ";
EndCombo                                         :: () #foreign imgui_lib "?EndCombo@ImGui@@YAXXZ";
EndDragDropSource                                :: () #foreign imgui_lib "?EndDragDropSource@ImGui@@YAXXZ";
EndDragDropTarget                                :: () #foreign imgui_lib "?EndDragDropTarget@ImGui@@YAXXZ";
EndFrame                                         :: () #foreign imgui_lib "?EndFrame@ImGui@@YAXXZ";
EndGroup                                         :: () #foreign imgui_lib "?EndGroup@ImGui@@YAXXZ";
EndMainMenuBar                                   :: () #foreign imgui_lib "?EndMainMenuBar@ImGui@@YAXXZ";
EndMenu                                          :: () #foreign imgui_lib "?EndMenu@ImGui@@YAXXZ";
EndMenuBar                                       :: () #foreign imgui_lib "?EndMenuBar@ImGui@@YAXXZ";
EndPopup                                         :: () #foreign imgui_lib "?EndPopup@ImGui@@YAXXZ";
EndTabBar                                        :: () #foreign imgui_lib "?EndTabBar@ImGui@@YAXXZ";
EndTabItem                                       :: () #foreign imgui_lib "?EndTabItem@ImGui@@YAXXZ";
EndTable                                         :: () #foreign imgui_lib "?EndTable@ImGui@@YAXXZ";
EndTooltip                                       :: () #foreign imgui_lib "?EndTooltip@ImGui@@YAXXZ";
FindOrCreateColumns                              :: (window: *Window, id: ID) -> *OldColumns #foreign imgui_lib "?FindOrCreateColumns@ImGui@@YAPEAUImGuiOldColumns@@PEAUImGuiWindow@@I@Z";
FindOrCreateWindowSettings                       :: (name: *u8) -> *WindowSettings #foreign imgui_lib "?FindOrCreateWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@PEBD@Z";
FindRenderedTextEnd                              :: (text: string) -> *u8 {
    _internal_FindRenderedTextEnd :: (text: *u8, text_end: *u8) -> *u8 #foreign imgui_lib "?FindRenderedTextEnd@ImGui@@YAPEBDPEBD0@Z";
    return _internal_FindRenderedTextEnd(text.data, text.data + text.count);
}
FindSettingsHandler                              :: (type_name: *u8) -> *SettingsHandler #foreign imgui_lib "?FindSettingsHandler@ImGui@@YAPEAUImGuiSettingsHandler@@PEBD@Z";
FindViewportByID                                 :: (id: ID) -> *Viewport #foreign imgui_lib "?FindViewportByID@ImGui@@YAPEAUImGuiViewport@@I@Z";
FindViewportByPlatformHandle                     :: (platform_handle: *void) -> *Viewport #foreign imgui_lib "?FindViewportByPlatformHandle@ImGui@@YAPEAUImGuiViewport@@PEAX@Z";
FindWindowByID                                   :: (id: ID) -> *Window #foreign imgui_lib "?FindWindowByID@ImGui@@YAPEAUImGuiWindow@@I@Z";
FindWindowByName                                 :: (name: *u8) -> *Window #foreign imgui_lib "?FindWindowByName@ImGui@@YAPEAUImGuiWindow@@PEBD@Z";
FindWindowSettings                               :: (id: ID) -> *WindowSettings #foreign imgui_lib "?FindWindowSettings@ImGui@@YAPEAUImGuiWindowSettings@@I@Z";
FocusTopMostWindowUnderOne                       :: (under_this_window: *Window, ignore_window: *Window) #foreign imgui_lib "?FocusTopMostWindowUnderOne@ImGui@@YAXPEAUImGuiWindow@@0@Z";
FocusWindow                                      :: (window: *Window) #foreign imgui_lib "?FocusWindow@ImGui@@YAXPEAUImGuiWindow@@@Z";
FocusableItemRegister                            :: (window: *Window, id: ID) -> bool #foreign imgui_lib "?FocusableItemRegister@ImGui@@YA_NPEAUImGuiWindow@@I@Z";
FocusableItemUnregister                          :: (window: *Window) #foreign imgui_lib "?FocusableItemUnregister@ImGui@@YAXPEAUImGuiWindow@@@Z";
GcAwakeTransientWindowBuffers                    :: (window: *Window) #foreign imgui_lib "?GcAwakeTransientWindowBuffers@ImGui@@YAXPEAUImGuiWindow@@@Z";
GcCompactTransientMiscBuffers                    :: () #foreign imgui_lib "?GcCompactTransientMiscBuffers@ImGui@@YAXXZ";
GcCompactTransientWindowBuffers                  :: (window: *Window) #foreign imgui_lib "?GcCompactTransientWindowBuffers@ImGui@@YAXPEAUImGuiWindow@@@Z";
GetBackgroundDrawList                            :: () -> *ImDrawList #foreign imgui_lib "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@XZ";
GetBackgroundDrawList                            :: (viewport: *Viewport) -> *ImDrawList #foreign imgui_lib "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z";
GetClipboardText                                 :: () -> *u8 #foreign imgui_lib "?GetClipboardText@ImGui@@YAPEBDXZ";
GetColorU32                                      :: (idx: Col, alpha_mul: float = 1.0) -> u32 #foreign imgui_lib "?GetColorU32@ImGui@@YAIHM@Z";
GetColorU32                                      :: (col: ImVec4) -> u32 {
    _internal_GetColorU32 :: (col: *ImVec4) -> u32 #foreign imgui_lib "?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z";
    return _internal_GetColorU32(*col);
}
GetColorU32                                      :: (col: u32) -> u32 #foreign imgui_lib "?GetColorU32@ImGui@@YAII@Z";
GetColumnIndex                                   :: () -> s32 #foreign imgui_lib "?GetColumnIndex@ImGui@@YAHXZ";
GetColumnNormFromOffset                          :: (columns: *OldColumns, offset: float) -> float #foreign imgui_lib "?GetColumnNormFromOffset@ImGui@@YAMPEBUImGuiOldColumns@@M@Z";
GetColumnOffset                                  :: (column_index: s32 = -1) -> float #foreign imgui_lib "?GetColumnOffset@ImGui@@YAMH@Z";
GetColumnOffsetFromNorm                          :: (columns: *OldColumns, offset_norm: float) -> float #foreign imgui_lib "?GetColumnOffsetFromNorm@ImGui@@YAMPEBUImGuiOldColumns@@M@Z";
GetColumnWidth                                   :: (column_index: s32 = -1) -> float #foreign imgui_lib "?GetColumnWidth@ImGui@@YAMH@Z";
GetColumnsCount                                  :: () -> s32 #foreign imgui_lib "?GetColumnsCount@ImGui@@YAHXZ";
GetColumnsID                                     :: (str_id: *u8, count: s32) -> ID #foreign imgui_lib "?GetColumnsID@ImGui@@YAIPEBDH@Z";
GetCurrentContext                                :: () -> *Context #foreign imgui_lib "?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ";
GetCursorPosX                                    :: () -> float #foreign imgui_lib "?GetCursorPosX@ImGui@@YAMXZ";
GetCursorPosY                                    :: () -> float #foreign imgui_lib "?GetCursorPosY@ImGui@@YAMXZ";
GetDragDropPayload                               :: () -> *Payload #foreign imgui_lib "?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ";
GetDrawData                                      :: () -> *ImDrawData #foreign imgui_lib "?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ";
GetDrawListSharedData                            :: () -> *ImDrawListSharedData #foreign imgui_lib "?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ";
GetFont                                          :: () -> *ImFont #foreign imgui_lib "?GetFont@ImGui@@YAPEAUImFont@@XZ";
GetFontSize                                      :: () -> float #foreign imgui_lib "?GetFontSize@ImGui@@YAMXZ";
GetForegroundDrawList                            :: () -> *ImDrawList #foreign imgui_lib "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ";
GetForegroundDrawList                            :: (viewport: *Viewport) -> *ImDrawList #foreign imgui_lib "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z";
GetFrameCount                                    :: () -> s32 #foreign imgui_lib "?GetFrameCount@ImGui@@YAHXZ";
GetFrameHeight                                   :: () -> float #foreign imgui_lib "?GetFrameHeight@ImGui@@YAMXZ";
GetFrameHeightWithSpacing                        :: () -> float #foreign imgui_lib "?GetFrameHeightWithSpacing@ImGui@@YAMXZ";
GetHoveredID                                     :: () -> ID #foreign imgui_lib "?GetHoveredID@ImGui@@YAIXZ";
GetID                                            :: (str_id: *u8) -> ID #foreign imgui_lib "?GetID@ImGui@@YAIPEBD@Z";
GetID                                            :: (str_id: string) -> ID {
    _internal_GetID :: (str_id_begin: *u8, str_id_end: *u8) -> ID #foreign imgui_lib "?GetID@ImGui@@YAIPEBD0@Z";
    return _internal_GetID(str_id.data, str_id.data + str_id.count);
}
GetID                                            :: (ptr_id: *void) -> ID #foreign imgui_lib "?GetID@ImGui@@YAIPEBX@Z";
GetIDWithSeed                                    :: (str_id: string, seed: ID) -> ID {
    _internal_GetIDWithSeed :: (str_id_begin: *u8, str_id_end: *u8, seed: ID) -> ID #foreign imgui_lib "?GetIDWithSeed@ImGui@@YAIPEBD0I@Z";
    return _internal_GetIDWithSeed(str_id.data, str_id.data + str_id.count, seed);
}
GetIO                                            :: () -> *IO #foreign imgui_lib "?GetIO@ImGui@@YAAEAUImGuiIO@@XZ";
GetKeyIndex                                      :: (imgui_key: Key) -> s32 #foreign imgui_lib "?GetKeyIndex@ImGui@@YAHH@Z";
GetKeyPressedAmount                              :: (key_index: s32, repeat_delay: float, rate: float) -> s32 #foreign imgui_lib "?GetKeyPressedAmount@ImGui@@YAHHMM@Z";
GetMainViewport                                  :: () -> *Viewport #foreign imgui_lib "?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ";
GetMergedKeyModFlags                             :: () -> KeyModFlags #foreign imgui_lib "?GetMergedKeyModFlags@ImGui@@YAHXZ";
GetMouseCursor                                   :: () -> MouseCursor #foreign imgui_lib "?GetMouseCursor@ImGui@@YAHXZ";
GetPlatformIO                                    :: () -> *PlatformIO #foreign imgui_lib "?GetPlatformIO@ImGui@@YAAEAUImGuiPlatformIO@@XZ";
GetScrollMaxX                                    :: () -> float #foreign imgui_lib "?GetScrollMaxX@ImGui@@YAMXZ";
GetScrollMaxY                                    :: () -> float #foreign imgui_lib "?GetScrollMaxY@ImGui@@YAMXZ";
GetScrollX                                       :: () -> float #foreign imgui_lib "?GetScrollX@ImGui@@YAMXZ";
GetScrollY                                       :: () -> float #foreign imgui_lib "?GetScrollY@ImGui@@YAMXZ";
GetStateStorage                                  :: () -> *Storage #foreign imgui_lib "?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ";
GetStyle                                         :: () -> *Style #foreign imgui_lib "?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ";
GetStyleColorName                                :: (idx: Col) -> *u8 #foreign imgui_lib "?GetStyleColorName@ImGui@@YAPEBDH@Z";
GetStyleColorVec4                                :: (idx: Col) -> *ImVec4 #foreign imgui_lib "?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z";
GetTextLineHeight                                :: () -> float #foreign imgui_lib "?GetTextLineHeight@ImGui@@YAMXZ";
GetTextLineHeightWithSpacing                     :: () -> float #foreign imgui_lib "?GetTextLineHeightWithSpacing@ImGui@@YAMXZ";
GetTime                                          :: () -> float64 #foreign imgui_lib "?GetTime@ImGui@@YANXZ";
GetTopMostPopupModal                             :: () -> *Window #foreign imgui_lib "?GetTopMostPopupModal@ImGui@@YAPEAUImGuiWindow@@XZ";
GetTreeNodeToLabelSpacing                        :: () -> float #foreign imgui_lib "?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ";
GetVersion                                       :: () -> *u8 #foreign imgui_lib "?GetVersion@ImGui@@YAPEBDXZ";
GetWindowAlwaysWantOwnTabBar                     :: (window: *Window) -> bool #foreign imgui_lib "?GetWindowAlwaysWantOwnTabBar@ImGui@@YA_NPEAUImGuiWindow@@@Z";
GetWindowContentRegionWidth                      :: () -> float #foreign imgui_lib "?GetWindowContentRegionWidth@ImGui@@YAMXZ";
GetWindowDockID                                  :: () -> ID #foreign imgui_lib "?GetWindowDockID@ImGui@@YAIXZ";
GetWindowDpiScale                                :: () -> float #foreign imgui_lib "?GetWindowDpiScale@ImGui@@YAMXZ";
GetWindowDrawList                                :: () -> *ImDrawList #foreign imgui_lib "?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ";
GetWindowHeight                                  :: () -> float #foreign imgui_lib "?GetWindowHeight@ImGui@@YAMXZ";
GetWindowResizeID                                :: (window: *Window, n: s32) -> ID #foreign imgui_lib "?GetWindowResizeID@ImGui@@YAIPEAUImGuiWindow@@H@Z";
GetWindowViewport                                :: () -> *Viewport #foreign imgui_lib "?GetWindowViewport@ImGui@@YAPEAUImGuiViewport@@XZ";
GetWindowWidth                                   :: () -> float #foreign imgui_lib "?GetWindowWidth@ImGui@@YAMXZ";
ImAlphaBlendColors                               :: (col_a: u32, col_b: u32) -> u32 #foreign imgui_lib "?ImAlphaBlendColors@@YAIII@Z";
ImFileLoadToMemory                               :: (filename: *u8, mode: *u8, out_file_size: *u64 = null, padding_bytes: s32 = 0) -> *void #foreign imgui_lib "?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z";
ImFontAtlasBuildFinish                           :: (atlas: *ImFontAtlas) #foreign imgui_lib "?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z";
ImFontAtlasBuildInit                             :: (atlas: *ImFontAtlas) #foreign imgui_lib "?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z";
ImFontAtlasBuildMultiplyCalcLookupTable          :: (out_table: [256]u8, in_multiply_factor: float) #foreign imgui_lib "?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z";
ImFontAtlasBuildPackCustomRects                  :: (atlas: *ImFontAtlas, stbrp_context_opaque: *void) #foreign imgui_lib "?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z";
ImFontAtlasBuildRender1bppRectFromString         :: (atlas: *ImFontAtlas, atlas_x: s32, atlas_y: s32, w: s32, h: s32, in_str: *u8, in_marker_char: s8, in_marker_pixel_value: u8) #foreign imgui_lib "?ImFontAtlasBuildRender1bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z";
ImFontAtlasBuildSetupFont                        :: (atlas: *ImFontAtlas, font: *ImFont, font_config: *ImFontConfig, ascent: float, descent: float) #foreign imgui_lib "?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z";
ImFontAtlasBuildWithStbTruetype                  :: (atlas: *ImFontAtlas) -> bool #foreign imgui_lib "?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z";
ImFormatString                                   :: (buf: *u8, buf_size: u64, fmt: *u8, args: ..Any) -> s32 #foreign imgui_lib "?ImFormatString@@YAHPEAD_KPEBDZZ";
ImGetDirQuadrantFromDelta                        :: (dx: float, dy: float) -> Dir #foreign imgui_lib "?ImGetDirQuadrantFromDelta@@YAHMM@Z";
ImHashData                                       :: (data: *void, data_size: u64, seed: u32 = 0) -> ID #foreign imgui_lib "?ImHashData@@YAIPEBX_KI@Z";
ImHashStr                                        :: (data: *u8, data_size: u64 = 0, seed: u32 = 0) -> ID #foreign imgui_lib "?ImHashStr@@YAIPEBD_KI@Z";
ImParseFormatFindEnd                             :: (format: *u8) -> *u8 #foreign imgui_lib "?ImParseFormatFindEnd@@YAPEBDPEBD@Z";
ImParseFormatFindStart                           :: (format: *u8) -> *u8 #foreign imgui_lib "?ImParseFormatFindStart@@YAPEBDPEBD@Z";
ImParseFormatPrecision                           :: (format: *u8, default_value: s32) -> s32 #foreign imgui_lib "?ImParseFormatPrecision@@YAHPEBDH@Z";
ImParseFormatTrimDecorations                     :: (format: *u8, buf: *u8, buf_size: u64) -> *u8 #foreign imgui_lib "?ImParseFormatTrimDecorations@@YAPEBDPEBDPEAD_K@Z";
ImStrSkipBlank                                   :: (str: *u8) -> *u8 #foreign imgui_lib "?ImStrSkipBlank@@YAPEBDPEBD@Z";
ImStrTrimBlanks                                  :: (str: *u8) #foreign imgui_lib "?ImStrTrimBlanks@@YAXPEAD@Z";
ImStrbolW                                        :: (buf_mid_line: *ImWchar, buf_begin: *ImWchar) -> *ImWchar #foreign imgui_lib "?ImStrbolW@@YAPEBGPEBG0@Z";
ImStrchrRange                                    :: (str: string, c: s8) -> *u8 {
    _internal_ImStrchrRange :: (str_begin: *u8, str_end: *u8, c: s8) -> *u8 #foreign imgui_lib "?ImStrchrRange@@YAPEBDPEBD0D@Z";
    return _internal_ImStrchrRange(str.data, str.data + str.count, c);
}
ImStrdup                                         :: (str: *u8) -> *u8 #foreign imgui_lib "?ImStrdup@@YAPEADPEBD@Z";
ImStrdupcpy                                      :: (dst: *u8, p_dst_size: *u64, str: *u8) -> *u8 #foreign imgui_lib "?ImStrdupcpy@@YAPEADPEADPEA_KPEBD@Z";
ImStreolRange                                    :: (str: string) -> *u8 {
    _internal_ImStreolRange :: (str: *u8, str_end: *u8) -> *u8 #foreign imgui_lib "?ImStreolRange@@YAPEBDPEBD0@Z";
    return _internal_ImStreolRange(str.data, str.data + str.count);
}
ImStricmp                                        :: (str1: *u8, str2: *u8) -> s32 #foreign imgui_lib "?ImStricmp@@YAHPEBD0@Z";
ImStristr                                        :: (haystack: string, needle: *u8, needle_end: *u8) -> *u8 {
    _internal_ImStristr :: (haystack: *u8, haystack_end: *u8, needle: *u8, needle_end: *u8) -> *u8 #foreign imgui_lib "?ImStristr@@YAPEBDPEBD000@Z";
    return _internal_ImStristr(haystack.data, haystack.data + haystack.count, needle, needle_end);
}
ImStrlenW                                        :: (str: *ImWchar) -> s32 #foreign imgui_lib "?ImStrlenW@@YAHPEBG@Z";
ImStrncpy                                        :: (dst: *u8, src: *u8, count: u64) #foreign imgui_lib "?ImStrncpy@@YAXPEADPEBD_K@Z";
ImStrnicmp                                       :: (str1: *u8, str2: *u8, count: u64) -> s32 #foreign imgui_lib "?ImStrnicmp@@YAHPEBD0_K@Z";
ImTextCharFromUtf8                               :: (out_char: *u32, in_text: string) -> s32 {
    _internal_ImTextCharFromUtf8 :: (out_char: *u32, in_text: *u8, in_text_end: *u8) -> s32 #foreign imgui_lib "?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z";
    return _internal_ImTextCharFromUtf8(out_char, in_text.data, in_text.data + in_text.count);
}
ImTextCountCharsFromUtf8                         :: (in_text: string) -> s32 {
    _internal_ImTextCountCharsFromUtf8 :: (in_text: *u8, in_text_end: *u8) -> s32 #foreign imgui_lib "?ImTextCountCharsFromUtf8@@YAHPEBD0@Z";
    return _internal_ImTextCountCharsFromUtf8(in_text.data, in_text.data + in_text.count);
}
ImTextCountUtf8BytesFromChar                     :: (in_text: string) -> s32 {
    _internal_ImTextCountUtf8BytesFromChar :: (in_text: *u8, in_text_end: *u8) -> s32 #foreign imgui_lib "?ImTextCountUtf8BytesFromChar@@YAHPEBD0@Z";
    return _internal_ImTextCountUtf8BytesFromChar(in_text.data, in_text.data + in_text.count);
}
ImTextCountUtf8BytesFromStr                      :: (in_text: *ImWchar, in_text_end: *ImWchar) -> s32 #foreign imgui_lib "?ImTextCountUtf8BytesFromStr@@YAHPEBG0@Z";
ImTextStrFromUtf8                                :: (buf: *ImWchar, buf_size: s32, in_text: string, in_remaining: **u8 = null) -> s32 {
    _internal_ImTextStrFromUtf8 :: (buf: *ImWchar, buf_size: s32, in_text: *u8, in_text_end: *u8, in_remaining: **u8) -> s32 #foreign imgui_lib "?ImTextStrFromUtf8@@YAHPEAGHPEBD1PEAPEBD@Z";
    return _internal_ImTextStrFromUtf8(buf, buf_size, in_text.data, in_text.data + in_text.count, in_remaining);
}
ImTextStrToUtf8                                  :: (buf: *u8, buf_size: s32, in_text: *ImWchar, in_text_end: *ImWchar) -> s32 #foreign imgui_lib "?ImTextStrToUtf8@@YAHPEADHPEBG1@Z";
ImTriangleBarycentricCoords                      :: (a: ImVec2, b: ImVec2, c: ImVec2, p: ImVec2, out_u: *float, out_v: *float, out_w: *float) {
    _internal_ImTriangleBarycentricCoords :: (a: *ImVec2, b: *ImVec2, c: *ImVec2, p: *ImVec2, out_u: *float, out_v: *float, out_w: *float) #foreign imgui_lib "?ImTriangleBarycentricCoords@@YAXAEBUImVec2@@000AEAM11@Z";
    _internal_ImTriangleBarycentricCoords(*a, *b, *c, *p, out_u, out_v, out_w);
}
ImTriangleContainsPoint                          :: (a: ImVec2, b: ImVec2, c: ImVec2, p: ImVec2) -> bool {
    _internal_ImTriangleContainsPoint :: (a: *ImVec2, b: *ImVec2, c: *ImVec2, p: *ImVec2) -> bool #foreign imgui_lib "?ImTriangleContainsPoint@@YA_NAEBUImVec2@@000@Z";
    return _internal_ImTriangleContainsPoint(*a, *b, *c, *p);
}
Image                                            :: (user_texture_id: ImTextureID, size: ImVec2, uv0: ImVec2 = ImVec2.{0,0}, uv1: ImVec2 = ImVec2.{1,1}, tint_col: ImVec4 = ImVec4.{1,1,1,1}, border_col: ImVec4 = ImVec4.{0,0,0,0}) {
    _internal_Image :: (user_texture_id: ImTextureID, size: *ImVec2, uv0: *ImVec2, uv1: *ImVec2, tint_col: *ImVec4, border_col: *ImVec4) #foreign imgui_lib "?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z";
    _internal_Image(user_texture_id, *size, *uv0, *uv1, *tint_col, *border_col);
}
ImageButton                                      :: (user_texture_id: ImTextureID, size: ImVec2, uv0: ImVec2 = ImVec2.{0,0}, uv1: ImVec2 = ImVec2.{1,1}, frame_padding: s32 = -1, bg_col: ImVec4 = ImVec4.{0,0,0,0}, tint_col: ImVec4 = ImVec4.{1,1,1,1}) -> bool {
    _internal_ImageButton :: (user_texture_id: ImTextureID, size: *ImVec2, uv0: *ImVec2, uv1: *ImVec2, frame_padding: s32, bg_col: *ImVec4, tint_col: *ImVec4) -> bool #foreign imgui_lib "?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z";
    return _internal_ImageButton(user_texture_id, *size, *uv0, *uv1, frame_padding, *bg_col, *tint_col);
}
ImageButtonEx                                    :: (id: ID, texture_id: ImTextureID, size: ImVec2, uv0: ImVec2, uv1: ImVec2, padding: ImVec2, bg_col: ImVec4, tint_col: ImVec4) -> bool {
    _internal_ImageButtonEx :: (id: ID, texture_id: ImTextureID, size: *ImVec2, uv0: *ImVec2, uv1: *ImVec2, padding: *ImVec2, bg_col: *ImVec4, tint_col: *ImVec4) -> bool #foreign imgui_lib "?ImageButtonEx@ImGui@@YA_NIPEAXAEBUImVec2@@111AEBUImVec4@@2@Z";
    return _internal_ImageButtonEx(id, texture_id, *size, *uv0, *uv1, *padding, *bg_col, *tint_col);
}
Indent                                           :: (indent_w: float = 0.0) #foreign imgui_lib "?Indent@ImGui@@YAXM@Z";
Initialize                                       :: (ctx: *Context) #foreign imgui_lib "?Initialize@ImGui@@YAXPEAUImGuiContext@@@Z";
InputDouble                                      :: (label: *u8, v: *float64, step: float64 = 0, step_fast: float64 = 0, format: *u8 = "%.6f", flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z";
InputFloat                                       :: (label: *u8, v: *float, step: float = 0.0, step_fast: float = 0.0, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z";
InputFloat2                                      :: (label: *u8, v: [2]float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z";
InputFloat3                                      :: (label: *u8, v: [3]float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z";
InputFloat4                                      :: (label: *u8, v: [4]float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z";
InputInt                                         :: (label: *u8, v: *s32, step: s32 = 1, step_fast: s32 = 100, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z";
InputInt2                                        :: (label: *u8, v: [2]s32, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputInt2@ImGui@@YA_NPEBDQEAHH@Z";
InputInt3                                        :: (label: *u8, v: [3]s32, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputInt3@ImGui@@YA_NPEBDQEAHH@Z";
InputInt4                                        :: (label: *u8, v: [4]s32, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputInt4@ImGui@@YA_NPEBDQEAHH@Z";
InputScalar                                      :: (label: *u8, data_type: DataType, p_data: *void, p_step: *void = null, p_step_fast: *void = null, format: *u8 = null, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z";
InputScalarN                                     :: (label: *u8, data_type: DataType, p_data: *void, components: s32, p_step: *void = null, p_step_fast: *void = null, format: *u8 = null, flags: InputTextFlags = .None) -> bool #foreign imgui_lib "?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z";
InputText                                        :: (label: *u8, buf: *u8, buf_size: u64, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool #foreign imgui_lib "?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
InputTextEx                                      :: (label: *u8, hint: *u8, buf: *u8, buf_size: s32, size_arg: ImVec2, flags: InputTextFlags, callback: InputTextCallback = null, user_data: *void = null) -> bool {
    _internal_InputTextEx :: (label: *u8, hint: *u8, buf: *u8, buf_size: s32, size_arg: *ImVec2, flags: InputTextFlags, callback: InputTextCallback, user_data: *void) -> bool #foreign imgui_lib "?InputTextEx@ImGui@@YA_NPEBD0PEADHAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
    return _internal_InputTextEx(label, hint, buf, buf_size, *size_arg, flags, callback, user_data);
}
InputTextMultiline                               :: (label: *u8, buf: *u8, buf_size: u64, size: ImVec2 = ImVec2.{0,0}, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool {
    _internal_InputTextMultiline :: (label: *u8, buf: *u8, buf_size: u64, size: *ImVec2, flags: InputTextFlags, callback: InputTextCallback, user_data: *void) -> bool #foreign imgui_lib "?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
    return _internal_InputTextMultiline(label, buf, buf_size, *size, flags, callback, user_data);
}
InputTextWithHint                                :: (label: *u8, hint: *u8, buf: *u8, buf_size: u64, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool #foreign imgui_lib "?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
InvisibleButton                                  :: (str_id: *u8, size: ImVec2, flags: ButtonFlags = .None) -> bool {
    _internal_InvisibleButton :: (str_id: *u8, size: *ImVec2, flags: ButtonFlags) -> bool #foreign imgui_lib "?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z";
    return _internal_InvisibleButton(str_id, *size, flags);
}
IsAnyItemActive                                  :: () -> bool #foreign imgui_lib "?IsAnyItemActive@ImGui@@YA_NXZ";
IsAnyItemFocused                                 :: () -> bool #foreign imgui_lib "?IsAnyItemFocused@ImGui@@YA_NXZ";
IsAnyItemHovered                                 :: () -> bool #foreign imgui_lib "?IsAnyItemHovered@ImGui@@YA_NXZ";
IsAnyMouseDown                                   :: () -> bool #foreign imgui_lib "?IsAnyMouseDown@ImGui@@YA_NXZ";
IsClippedEx                                      :: (bb: ImRect, id: ID, clip_even_when_logged: bool) -> bool {
    _internal_IsClippedEx :: (bb: *ImRect, id: ID, clip_even_when_logged: bool) -> bool #foreign imgui_lib "?IsClippedEx@ImGui@@YA_NAEBUImRect@@I_N@Z";
    return _internal_IsClippedEx(*bb, id, clip_even_when_logged);
}
IsDragDropPayloadBeingAccepted                   :: () -> bool #foreign imgui_lib "?IsDragDropPayloadBeingAccepted@ImGui@@YA_NXZ";
IsItemActivated                                  :: () -> bool #foreign imgui_lib "?IsItemActivated@ImGui@@YA_NXZ";
IsItemActive                                     :: () -> bool #foreign imgui_lib "?IsItemActive@ImGui@@YA_NXZ";
IsItemClicked                                    :: (mouse_button: MouseButton = .Left) -> bool #foreign imgui_lib "?IsItemClicked@ImGui@@YA_NH@Z";
IsItemDeactivated                                :: () -> bool #foreign imgui_lib "?IsItemDeactivated@ImGui@@YA_NXZ";
IsItemDeactivatedAfterEdit                       :: () -> bool #foreign imgui_lib "?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ";
IsItemEdited                                     :: () -> bool #foreign imgui_lib "?IsItemEdited@ImGui@@YA_NXZ";
IsItemFocused                                    :: () -> bool #foreign imgui_lib "?IsItemFocused@ImGui@@YA_NXZ";
IsItemHovered                                    :: (flags: HoveredFlags = .None) -> bool #foreign imgui_lib "?IsItemHovered@ImGui@@YA_NH@Z";
IsItemToggledOpen                                :: () -> bool #foreign imgui_lib "?IsItemToggledOpen@ImGui@@YA_NXZ";
IsItemToggledSelection                           :: () -> bool #foreign imgui_lib "?IsItemToggledSelection@ImGui@@YA_NXZ";
IsItemVisible                                    :: () -> bool #foreign imgui_lib "?IsItemVisible@ImGui@@YA_NXZ";
IsKeyDown                                        :: (user_key_index: s32) -> bool #foreign imgui_lib "?IsKeyDown@ImGui@@YA_NH@Z";
IsKeyPressed                                     :: (user_key_index: s32, repeat: bool = true) -> bool #foreign imgui_lib "?IsKeyPressed@ImGui@@YA_NH_N@Z";
IsKeyReleased                                    :: (user_key_index: s32) -> bool #foreign imgui_lib "?IsKeyReleased@ImGui@@YA_NH@Z";
IsMouseClicked                                   :: (button: MouseButton, repeat: bool = false) -> bool #foreign imgui_lib "?IsMouseClicked@ImGui@@YA_NH_N@Z";
IsMouseDoubleClicked                             :: (button: MouseButton) -> bool #foreign imgui_lib "?IsMouseDoubleClicked@ImGui@@YA_NH@Z";
IsMouseDown                                      :: (button: MouseButton) -> bool #foreign imgui_lib "?IsMouseDown@ImGui@@YA_NH@Z";
IsMouseDragPastThreshold                         :: (button: MouseButton, lock_threshold: float = 1.0) -> bool #foreign imgui_lib "?IsMouseDragPastThreshold@ImGui@@YA_NHM@Z";
IsMouseDragging                                  :: (button: MouseButton, lock_threshold: float = 1.0) -> bool #foreign imgui_lib "?IsMouseDragging@ImGui@@YA_NHM@Z";
IsMouseHoveringRect                              :: (r_min: ImVec2, r_max: ImVec2, clip: bool = true) -> bool {
    _internal_IsMouseHoveringRect :: (r_min: *ImVec2, r_max: *ImVec2, clip: bool) -> bool #foreign imgui_lib "?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z";
    return _internal_IsMouseHoveringRect(*r_min, *r_max, clip);
}
IsMousePosValid                                  :: (mouse_pos: *ImVec2 = null) -> bool #foreign imgui_lib "?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z";
IsMouseReleased                                  :: (button: MouseButton) -> bool #foreign imgui_lib "?IsMouseReleased@ImGui@@YA_NH@Z";
IsPopupOpen                                      :: (str_id: *u8, flags: PopupFlags = .None) -> bool #foreign imgui_lib "?IsPopupOpen@ImGui@@YA_NPEBDH@Z";
IsPopupOpen                                      :: (id: ID, popup_flags: PopupFlags) -> bool #foreign imgui_lib "?IsPopupOpen@ImGui@@YA_NIH@Z";
IsRectVisible                                    :: (size: ImVec2) -> bool {
    _internal_IsRectVisible :: (size: *ImVec2) -> bool #foreign imgui_lib "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z";
    return _internal_IsRectVisible(*size);
}
IsRectVisible                                    :: (rect_min: ImVec2, rect_max: ImVec2) -> bool {
    _internal_IsRectVisible :: (rect_min: *ImVec2, rect_max: *ImVec2) -> bool #foreign imgui_lib "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z";
    return _internal_IsRectVisible(*rect_min, *rect_max);
}
IsWindowAbove                                    :: (potential_above: *Window, potential_below: *Window) -> bool #foreign imgui_lib "?IsWindowAbove@ImGui@@YA_NPEAUImGuiWindow@@0@Z";
IsWindowAppearing                                :: () -> bool #foreign imgui_lib "?IsWindowAppearing@ImGui@@YA_NXZ";
IsWindowChildOf                                  :: (window: *Window, potential_parent: *Window) -> bool #foreign imgui_lib "?IsWindowChildOf@ImGui@@YA_NPEAUImGuiWindow@@0@Z";
IsWindowCollapsed                                :: () -> bool #foreign imgui_lib "?IsWindowCollapsed@ImGui@@YA_NXZ";
IsWindowDocked                                   :: () -> bool #foreign imgui_lib "?IsWindowDocked@ImGui@@YA_NXZ";
IsWindowFocused                                  :: (flags: FocusedFlags = .None) -> bool #foreign imgui_lib "?IsWindowFocused@ImGui@@YA_NH@Z";
IsWindowHovered                                  :: (flags: HoveredFlags = .None) -> bool #foreign imgui_lib "?IsWindowHovered@ImGui@@YA_NH@Z";
IsWindowNavFocusable                             :: (window: *Window) -> bool #foreign imgui_lib "?IsWindowNavFocusable@ImGui@@YA_NPEAUImGuiWindow@@@Z";
ItemAdd                                          :: (bb: ImRect, id: ID, nav_bb: *ImRect = null) -> bool {
    _internal_ItemAdd :: (bb: *ImRect, id: ID, nav_bb: *ImRect) -> bool #foreign imgui_lib "?ItemAdd@ImGui@@YA_NAEBUImRect@@IPEBU2@@Z";
    return _internal_ItemAdd(*bb, id, nav_bb);
}
ItemHoverable                                    :: (bb: ImRect, id: ID) -> bool {
    _internal_ItemHoverable :: (bb: *ImRect, id: ID) -> bool #foreign imgui_lib "?ItemHoverable@ImGui@@YA_NAEBUImRect@@I@Z";
    return _internal_ItemHoverable(*bb, id);
}
ItemSize                                         :: (size: ImVec2, text_baseline_y: float = 1.0) {
    _internal_ItemSize :: (size: *ImVec2, text_baseline_y: float) #foreign imgui_lib "?ItemSize@ImGui@@YAXAEBUImVec2@@M@Z";
    _internal_ItemSize(*size, text_baseline_y);
}
ItemSize                                         :: (bb: ImRect, text_baseline_y: float = 1.0) {
    _internal_ItemSize :: (bb: *ImRect, text_baseline_y: float) #foreign imgui_lib "?ItemSize@ImGui@@YAXAEBUImRect@@M@Z";
    _internal_ItemSize(*bb, text_baseline_y);
}
KeepAliveID                                      :: (id: ID) #foreign imgui_lib "?KeepAliveID@ImGui@@YAXI@Z";
LabelText                                        :: (label: *u8, fmt: *u8, args: ..Any) #foreign imgui_lib "?LabelText@ImGui@@YAXPEBD0ZZ";
ListBox                                          :: (label: *u8, current_item: *s32, items: *[]u8, items_count: s32, height_in_items: s32 = -1) -> bool #foreign imgui_lib "?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z";
ListBox                                          :: (label: *u8, current_item: *s32, items_getter: (data: *void, idx: s32, out_text: **u8) -> bool #c_call, data: *void, items_count: s32, height_in_items: s32 = -1) -> bool #foreign imgui_lib "?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z";
ListBoxFooter                                    :: () #foreign imgui_lib "?ListBoxFooter@ImGui@@YAXXZ";
ListBoxHeader                                    :: (label: *u8, size: ImVec2 = ImVec2.{0,0}) -> bool {
    _internal_ListBoxHeader :: (label: *u8, size: *ImVec2) -> bool #foreign imgui_lib "?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z";
    return _internal_ListBoxHeader(label, *size);
}
ListBoxHeader                                    :: (label: *u8, items_count: s32, height_in_items: s32 = -1) -> bool #foreign imgui_lib "?ListBoxHeader@ImGui@@YA_NPEBDHH@Z";
LoadIniSettingsFromDisk                          :: (ini_filename: *u8) #foreign imgui_lib "?LoadIniSettingsFromDisk@ImGui@@YAXPEBD@Z";
LoadIniSettingsFromMemory                        :: (ini_data: *u8, ini_size: u64 = 0) #foreign imgui_lib "?LoadIniSettingsFromMemory@ImGui@@YAXPEBD_K@Z";
LogButtons                                       :: () #foreign imgui_lib "?LogButtons@ImGui@@YAXXZ";
LogFinish                                        :: () #foreign imgui_lib "?LogFinish@ImGui@@YAXXZ";
LogRenderedText                                  :: (ref_pos: *ImVec2, text: string) {
    _internal_LogRenderedText :: (ref_pos: *ImVec2, text: *u8, text_end: *u8) #foreign imgui_lib "?LogRenderedText@ImGui@@YAXPEBUImVec2@@PEBD1@Z";
    _internal_LogRenderedText(ref_pos, text.data, text.data + text.count);
}
LogText                                          :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?LogText@ImGui@@YAXPEBDZZ";
LogToBuffer                                      :: (auto_open_depth: s32 = -1) #foreign imgui_lib "?LogToBuffer@ImGui@@YAXH@Z";
LogToClipboard                                   :: (auto_open_depth: s32 = -1) #foreign imgui_lib "?LogToClipboard@ImGui@@YAXH@Z";
LogToFile                                        :: (auto_open_depth: s32 = -1, filename: *u8 = null) #foreign imgui_lib "?LogToFile@ImGui@@YAXHPEBD@Z";
LogToTTY                                         :: (auto_open_depth: s32 = -1) #foreign imgui_lib "?LogToTTY@ImGui@@YAXH@Z";
MarkIniSettingsDirty                             :: () #foreign imgui_lib "?MarkIniSettingsDirty@ImGui@@YAXXZ";
MarkIniSettingsDirty                             :: (window: *Window) #foreign imgui_lib "?MarkIniSettingsDirty@ImGui@@YAXPEAUImGuiWindow@@@Z";
MarkItemEdited                                   :: (id: ID) #foreign imgui_lib "?MarkItemEdited@ImGui@@YAXI@Z";
MemAlloc                                         :: (size: u64) -> *void #foreign imgui_lib "?MemAlloc@ImGui@@YAPEAX_K@Z";
MemFree                                          :: (ptr: *void) #foreign imgui_lib "?MemFree@ImGui@@YAXPEAX@Z";
MenuItem                                         :: (label: *u8, shortcut: *u8 = null, selected: bool = false, enabled: bool = true) -> bool #foreign imgui_lib "?MenuItem@ImGui@@YA_NPEBD0_N1@Z";
MenuItem                                         :: (label: *u8, shortcut: *u8, p_selected: *bool, enabled: bool = true) -> bool #foreign imgui_lib "?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z";
NavInitWindow                                    :: (window: *Window, force_reinit: bool) #foreign imgui_lib "?NavInitWindow@ImGui@@YAXPEAUImGuiWindow@@_N@Z";
NavMoveRequestButNoResultYet                     :: () -> bool #foreign imgui_lib "?NavMoveRequestButNoResultYet@ImGui@@YA_NXZ";
NavMoveRequestCancel                             :: () #foreign imgui_lib "?NavMoveRequestCancel@ImGui@@YAXXZ";
NavMoveRequestForward                            :: (move_dir: Dir, clip_dir: Dir, bb_rel: ImRect, move_flags: NavMoveFlags) {
    _internal_NavMoveRequestForward :: (move_dir: Dir, clip_dir: Dir, bb_rel: *ImRect, move_flags: NavMoveFlags) #foreign imgui_lib "?NavMoveRequestForward@ImGui@@YAXHHAEBUImRect@@H@Z";
    _internal_NavMoveRequestForward(move_dir, clip_dir, *bb_rel, move_flags);
}
NavMoveRequestTryWrapping                        :: (window: *Window, move_flags: NavMoveFlags) #foreign imgui_lib "?NavMoveRequestTryWrapping@ImGui@@YAXPEAUImGuiWindow@@H@Z";
NewFrame                                         :: () #foreign imgui_lib "?NewFrame@ImGui@@YAXXZ";
NewLine                                          :: () #foreign imgui_lib "?NewLine@ImGui@@YAXXZ";
NextColumn                                       :: () #foreign imgui_lib "?NextColumn@ImGui@@YAXXZ";
OpenPopup                                        :: (str_id: *u8, popup_flags: PopupFlags = .None) #foreign imgui_lib "?OpenPopup@ImGui@@YAXPEBDH@Z";
OpenPopupEx                                      :: (id: ID, popup_flags: PopupFlags = .None) #foreign imgui_lib "?OpenPopupEx@ImGui@@YAXIH@Z";
OpenPopupOnItemClick                             :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) #foreign imgui_lib "?OpenPopupOnItemClick@ImGui@@YAXPEBDH@Z";
PlotHistogram                                    :: (label: *u8, values: *float, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 3.402823466e+38, scale_max: float = 3.402823466e+38, graph_size: ImVec2 = ImVec2.{0,0}, stride: s32 = size_of(float)) #foreign imgui_lib "?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z";
PlotHistogram                                    :: (label: *u8, values_getter: (data: *void, idx: s32) -> float #c_call, data: *void, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 3.402823466e+38, scale_max: float = 3.402823466e+38, graph_size: ImVec2 = ImVec2.{0,0}) #foreign imgui_lib "?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z";
PlotLines                                        :: (label: *u8, values: *float, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 3.402823466e+38, scale_max: float = 3.402823466e+38, graph_size: ImVec2 = ImVec2.{0,0}, stride: s32 = size_of(float)) #foreign imgui_lib "?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z";
PlotLines                                        :: (label: *u8, values_getter: (data: *void, idx: s32) -> float #c_call, data: *void, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 3.402823466e+38, scale_max: float = 3.402823466e+38, graph_size: ImVec2 = ImVec2.{0,0}) #foreign imgui_lib "?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z";
PopAllowKeyboardFocus                            :: () #foreign imgui_lib "?PopAllowKeyboardFocus@ImGui@@YAXXZ";
PopButtonRepeat                                  :: () #foreign imgui_lib "?PopButtonRepeat@ImGui@@YAXXZ";
PopClipRect                                      :: () #foreign imgui_lib "?PopClipRect@ImGui@@YAXXZ";
PopColumnsBackground                             :: () #foreign imgui_lib "?PopColumnsBackground@ImGui@@YAXXZ";
PopFocusScope                                    :: () #foreign imgui_lib "?PopFocusScope@ImGui@@YAXXZ";
PopFont                                          :: () #foreign imgui_lib "?PopFont@ImGui@@YAXXZ";
PopID                                            :: () #foreign imgui_lib "?PopID@ImGui@@YAXXZ";
PopItemFlag                                      :: () #foreign imgui_lib "?PopItemFlag@ImGui@@YAXXZ";
PopItemWidth                                     :: () #foreign imgui_lib "?PopItemWidth@ImGui@@YAXXZ";
PopStyleColor                                    :: (count: s32 = 1) #foreign imgui_lib "?PopStyleColor@ImGui@@YAXH@Z";
PopStyleVar                                      :: (count: s32 = 1) #foreign imgui_lib "?PopStyleVar@ImGui@@YAXH@Z";
PopTextWrapPos                                   :: () #foreign imgui_lib "?PopTextWrapPos@ImGui@@YAXXZ";
ProgressBar                                      :: (fraction: float, size_arg: ImVec2 = ImVec2.{-1,0}, overlay: *u8 = null) {
    _internal_ProgressBar :: (fraction: float, size_arg: *ImVec2, overlay: *u8) #foreign imgui_lib "?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z";
    _internal_ProgressBar(fraction, *size_arg, overlay);
}
PushAllowKeyboardFocus                           :: (allow_keyboard_focus: bool) #foreign imgui_lib "?PushAllowKeyboardFocus@ImGui@@YAX_N@Z";
PushButtonRepeat                                 :: (repeat: bool) #foreign imgui_lib "?PushButtonRepeat@ImGui@@YAX_N@Z";
PushClipRect                                     :: (clip_rect_min: ImVec2, clip_rect_max: ImVec2, intersect_with_current_clip_rect: bool) {
    _internal_PushClipRect :: (clip_rect_min: *ImVec2, clip_rect_max: *ImVec2, intersect_with_current_clip_rect: bool) #foreign imgui_lib "?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z";
    _internal_PushClipRect(*clip_rect_min, *clip_rect_max, intersect_with_current_clip_rect);
}
PushColumnClipRect                               :: (column_index: s32) #foreign imgui_lib "?PushColumnClipRect@ImGui@@YAXH@Z";
PushColumnsBackground                            :: () #foreign imgui_lib "?PushColumnsBackground@ImGui@@YAXXZ";
PushFocusScope                                   :: (id: ID) #foreign imgui_lib "?PushFocusScope@ImGui@@YAXI@Z";
PushFont                                         :: (font: *ImFont) #foreign imgui_lib "?PushFont@ImGui@@YAXPEAUImFont@@@Z";
PushID                                           :: (str_id: *u8) #foreign imgui_lib "?PushID@ImGui@@YAXPEBD@Z";
PushID                                           :: (str_id: string) {
    _internal_PushID :: (str_id_begin: *u8, str_id_end: *u8) #foreign imgui_lib "?PushID@ImGui@@YAXPEBD0@Z";
    _internal_PushID(str_id.data, str_id.data + str_id.count);
}
PushID                                           :: (ptr_id: *void) #foreign imgui_lib "?PushID@ImGui@@YAXPEBX@Z";
PushID                                           :: (int_id: s32) #foreign imgui_lib "?PushID@ImGui@@YAXH@Z";
PushItemFlag                                     :: (option: ItemFlags, enabled: bool) #foreign imgui_lib "?PushItemFlag@ImGui@@YAXH_N@Z";
PushItemWidth                                    :: (item_width: float) #foreign imgui_lib "?PushItemWidth@ImGui@@YAXM@Z";
PushMultiItemsWidths                             :: (components: s32, width_full: float) #foreign imgui_lib "?PushMultiItemsWidths@ImGui@@YAXHM@Z";
PushOverrideID                                   :: (id: ID) #foreign imgui_lib "?PushOverrideID@ImGui@@YAXI@Z";
PushStyleColor                                   :: (idx: Col, col: u32) #foreign imgui_lib "?PushStyleColor@ImGui@@YAXHI@Z";
PushStyleColor                                   :: (idx: Col, col: ImVec4) {
    _internal_PushStyleColor :: (idx: Col, col: *ImVec4) #foreign imgui_lib "?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z";
    _internal_PushStyleColor(idx, *col);
}
PushStyleVar                                     :: (idx: StyleVar, val: float) #foreign imgui_lib "?PushStyleVar@ImGui@@YAXHM@Z";
PushStyleVar                                     :: (idx: StyleVar, val: ImVec2) {
    _internal_PushStyleVar :: (idx: StyleVar, val: *ImVec2) #foreign imgui_lib "?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z";
    _internal_PushStyleVar(idx, *val);
}
PushTextWrapPos                                  :: (wrap_local_pos_x: float = 0.0) #foreign imgui_lib "?PushTextWrapPos@ImGui@@YAXM@Z";
RadioButton                                      :: (label: *u8, active: bool) -> bool #foreign imgui_lib "?RadioButton@ImGui@@YA_NPEBD_N@Z";
RadioButton                                      :: (label: *u8, v: *s32, v_button: s32) -> bool #foreign imgui_lib "?RadioButton@ImGui@@YA_NPEBDPEAHH@Z";
Render                                           :: () #foreign imgui_lib "?Render@ImGui@@YAXXZ";
RenderArrow                                      :: (draw_list: *ImDrawList, pos: ImVec2, col: u32, dir: Dir, scale: float = 1.0) #foreign imgui_lib "?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z";
RenderArrowDockMenu                              :: (draw_list: *ImDrawList, p_min: ImVec2, sz: float, col: u32) #foreign imgui_lib "?RenderArrowDockMenu@ImGui@@YAXPEAUImDrawList@@UImVec2@@MI@Z";
RenderArrowPointingAt                            :: (draw_list: *ImDrawList, pos: ImVec2, half_sz: ImVec2, direction: Dir, col: u32) #foreign imgui_lib "?RenderArrowPointingAt@ImGui@@YAXPEAUImDrawList@@UImVec2@@1HI@Z";
RenderBullet                                     :: (draw_list: *ImDrawList, pos: ImVec2, col: u32) #foreign imgui_lib "?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z";
RenderCheckMark                                  :: (draw_list: *ImDrawList, pos: ImVec2, col: u32, sz: float) #foreign imgui_lib "?RenderCheckMark@ImGui@@YAXPEAUImDrawList@@UImVec2@@IM@Z";
RenderColorRectWithAlphaCheckerboard             :: (draw_list: *ImDrawList, p_min: ImVec2, p_max: ImVec2, fill_col: u32, grid_step: float, grid_off: ImVec2, rounding: float = 0.0, rounding_corners_flags: s32 = cast(s32)~0) #foreign imgui_lib "?RenderColorRectWithAlphaCheckerboard@ImGui@@YAXPEAUImDrawList@@UImVec2@@1IM1MH@Z";
RenderFrame                                      :: (p_min: ImVec2, p_max: ImVec2, fill_col: u32, border: bool = true, rounding: float = 0.0) #foreign imgui_lib "?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z";
RenderFrameBorder                                :: (p_min: ImVec2, p_max: ImVec2, rounding: float = 0.0) #foreign imgui_lib "?RenderFrameBorder@ImGui@@YAXUImVec2@@0M@Z";
RenderMouseCursor                                :: (draw_list: *ImDrawList, pos: ImVec2, scale: float, mouse_cursor: MouseCursor, col_fill: u32, col_border: u32, col_shadow: u32) #foreign imgui_lib "?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z";
RenderNavHighlight                               :: (bb: ImRect, id: ID, flags: NavHighlightFlags = .TypeDefault) {
    _internal_RenderNavHighlight :: (bb: *ImRect, id: ID, flags: NavHighlightFlags) #foreign imgui_lib "?RenderNavHighlight@ImGui@@YAXAEBUImRect@@IH@Z";
    _internal_RenderNavHighlight(*bb, id, flags);
}
RenderPlatformWindowsDefault                     :: (platform_render_arg: *void = null, renderer_render_arg: *void = null) #foreign imgui_lib "?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z";
RenderRectFilledRangeH                           :: (draw_list: *ImDrawList, rect: ImRect, col: u32, x_start_norm: float, x_end_norm: float, rounding: float) {
    _internal_RenderRectFilledRangeH :: (draw_list: *ImDrawList, rect: *ImRect, col: u32, x_start_norm: float, x_end_norm: float, rounding: float) #foreign imgui_lib "?RenderRectFilledRangeH@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@IMMM@Z";
    _internal_RenderRectFilledRangeH(draw_list, *rect, col, x_start_norm, x_end_norm, rounding);
}
RenderRectFilledWithHole                         :: (draw_list: *ImDrawList, outer: ImRect, inner: ImRect, col: u32, rounding: float) #foreign imgui_lib "?RenderRectFilledWithHole@ImGui@@YAXPEAUImDrawList@@UImRect@@1IM@Z";
RenderText                                       :: (pos: ImVec2, text: string, hide_text_after_hash: bool = true) {
    _internal_RenderText :: (pos: ImVec2, text: *u8, text_end: *u8, hide_text_after_hash: bool) #foreign imgui_lib "?RenderText@ImGui@@YAXUImVec2@@PEBD1_N@Z";
    _internal_RenderText(pos, text.data, text.data + text.count, hide_text_after_hash);
}
RenderTextClipped                                :: (pos_min: ImVec2, pos_max: ImVec2, text: string, text_size_if_known: *ImVec2, align: ImVec2 = ImVec2.{0,0}, clip_rect: *ImRect = null) {
    _internal_RenderTextClipped :: (pos_min: *ImVec2, pos_max: *ImVec2, text: *u8, text_end: *u8, text_size_if_known: *ImVec2, align: *ImVec2, clip_rect: *ImRect) #foreign imgui_lib "?RenderTextClipped@ImGui@@YAXAEBUImVec2@@0PEBD1PEBU2@0PEBUImRect@@@Z";
    _internal_RenderTextClipped(*pos_min, *pos_max, text.data, text.data + text.count, text_size_if_known, *align, clip_rect);
}
RenderTextClippedEx                              :: (draw_list: *ImDrawList, pos_min: ImVec2, pos_max: ImVec2, text: string, text_size_if_known: *ImVec2, align: ImVec2 = ImVec2.{0,0}, clip_rect: *ImRect = null) {
    _internal_RenderTextClippedEx :: (draw_list: *ImDrawList, pos_min: *ImVec2, pos_max: *ImVec2, text: *u8, text_end: *u8, text_size_if_known: *ImVec2, align: *ImVec2, clip_rect: *ImRect) #foreign imgui_lib "?RenderTextClippedEx@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1PEBD2PEBU3@1PEBUImRect@@@Z";
    _internal_RenderTextClippedEx(draw_list, *pos_min, *pos_max, text.data, text.data + text.count, text_size_if_known, *align, clip_rect);
}
RenderTextEllipsis                               :: (draw_list: *ImDrawList, pos_min: ImVec2, pos_max: ImVec2, clip_max_x: float, ellipsis_max_x: float, text: string, text_size_if_known: *ImVec2) {
    _internal_RenderTextEllipsis :: (draw_list: *ImDrawList, pos_min: *ImVec2, pos_max: *ImVec2, clip_max_x: float, ellipsis_max_x: float, text: *u8, text_end: *u8, text_size_if_known: *ImVec2) #foreign imgui_lib "?RenderTextEllipsis@ImGui@@YAXPEAUImDrawList@@AEBUImVec2@@1MMPEBD2PEBU3@@Z";
    _internal_RenderTextEllipsis(draw_list, *pos_min, *pos_max, clip_max_x, ellipsis_max_x, text.data, text.data + text.count, text_size_if_known);
}
RenderTextWrapped                                :: (pos: ImVec2, text: string, wrap_width: float) {
    _internal_RenderTextWrapped :: (pos: ImVec2, text: *u8, text_end: *u8, wrap_width: float) #foreign imgui_lib "?RenderTextWrapped@ImGui@@YAXUImVec2@@PEBD1M@Z";
    _internal_RenderTextWrapped(pos, text.data, text.data + text.count, wrap_width);
}
ResetMouseDragDelta                              :: (button: MouseButton = .Left) #foreign imgui_lib "?ResetMouseDragDelta@ImGui@@YAXH@Z";
SameLine                                         :: (offset_from_start_x: float = 0.0, spacing: float = 1.0) #foreign imgui_lib "?SameLine@ImGui@@YAXMM@Z";
SaveIniSettingsToDisk                            :: (ini_filename: *u8) #foreign imgui_lib "?SaveIniSettingsToDisk@ImGui@@YAXPEBD@Z";
SaveIniSettingsToMemory                          :: (out_ini_size: *u64 = null) -> *u8 #foreign imgui_lib "?SaveIniSettingsToMemory@ImGui@@YAPEBDPEA_K@Z";
ScaleWindowsInViewport                           :: (viewport: *ViewportP, scale: float) #foreign imgui_lib "?ScaleWindowsInViewport@ImGui@@YAXPEAUImGuiViewportP@@M@Z";
Selectable                                       :: (label: *u8, selected: bool = false, flags: SelectableFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
    _internal_Selectable :: (label: *u8, selected: bool, flags: SelectableFlags, size: *ImVec2) -> bool #foreign imgui_lib "?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z";
    return _internal_Selectable(label, selected, flags, *size);
}
Selectable                                       :: (label: *u8, p_selected: *bool, flags: SelectableFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
    _internal_Selectable :: (label: *u8, p_selected: *bool, flags: SelectableFlags, size: *ImVec2) -> bool #foreign imgui_lib "?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z";
    return _internal_Selectable(label, p_selected, flags, *size);
}
Separator                                        :: () #foreign imgui_lib "?Separator@ImGui@@YAXXZ";
SeparatorEx                                      :: (flags: SeparatorFlags) #foreign imgui_lib "?SeparatorEx@ImGui@@YAXH@Z";
SetActiveID                                      :: (id: ID, window: *Window) #foreign imgui_lib "?SetActiveID@ImGui@@YAXIPEAUImGuiWindow@@@Z";
SetAllocatorFunctions                            :: (alloc_func: (sz: u64, user_data: *void) -> *void #c_call, free_func: (ptr: *void, user_data: *void) #c_call, user_data: *void = null) #foreign imgui_lib "?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z";
SetClipboardText                                 :: (text: *u8) #foreign imgui_lib "?SetClipboardText@ImGui@@YAXPEBD@Z";
SetColorEditOptions                              :: (flags: ColorEditFlags) #foreign imgui_lib "?SetColorEditOptions@ImGui@@YAXH@Z";
SetColumnOffset                                  :: (column_index: s32, offset_x: float) #foreign imgui_lib "?SetColumnOffset@ImGui@@YAXHM@Z";
SetColumnWidth                                   :: (column_index: s32, width: float) #foreign imgui_lib "?SetColumnWidth@ImGui@@YAXHM@Z";
SetCurrentContext                                :: (ctx: *Context) #foreign imgui_lib "?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z";
SetCurrentFont                                   :: (font: *ImFont) #foreign imgui_lib "?SetCurrentFont@ImGui@@YAXPEAUImFont@@@Z";
SetCursorPos                                     :: (local_pos: ImVec2) {
    _internal_SetCursorPos :: (local_pos: *ImVec2) #foreign imgui_lib "?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z";
    _internal_SetCursorPos(*local_pos);
}
SetCursorPosX                                    :: (local_x: float) #foreign imgui_lib "?SetCursorPosX@ImGui@@YAXM@Z";
SetCursorPosY                                    :: (local_y: float) #foreign imgui_lib "?SetCursorPosY@ImGui@@YAXM@Z";
SetCursorScreenPos                               :: (pos: ImVec2) {
    _internal_SetCursorScreenPos :: (pos: *ImVec2) #foreign imgui_lib "?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z";
    _internal_SetCursorScreenPos(*pos);
}
SetDragDropPayload                               :: (type: *u8, data: *void, sz: u64, cond: Cond = .None) -> bool #foreign imgui_lib "?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z";
SetFocusID                                       :: (id: ID, window: *Window) #foreign imgui_lib "?SetFocusID@ImGui@@YAXIPEAUImGuiWindow@@@Z";
SetHoveredID                                     :: (id: ID) #foreign imgui_lib "?SetHoveredID@ImGui@@YAXI@Z";
SetItemAllowOverlap                              :: () #foreign imgui_lib "?SetItemAllowOverlap@ImGui@@YAXXZ";
SetItemDefaultFocus                              :: () #foreign imgui_lib "?SetItemDefaultFocus@ImGui@@YAXXZ";
SetKeyboardFocusHere                             :: (offset: s32 = 0) #foreign imgui_lib "?SetKeyboardFocusHere@ImGui@@YAXH@Z";
SetLastItemData                                  :: (window: *Window, item_id: ID, status_flags: ItemStatusFlags, item_rect: ImRect) {
    _internal_SetLastItemData :: (window: *Window, item_id: ID, status_flags: ItemStatusFlags, item_rect: *ImRect) #foreign imgui_lib "?SetLastItemData@ImGui@@YAXPEAUImGuiWindow@@IHAEBUImRect@@@Z";
    _internal_SetLastItemData(window, item_id, status_flags, *item_rect);
}
SetMouseCursor                                   :: (cursor_type: MouseCursor) #foreign imgui_lib "?SetMouseCursor@ImGui@@YAXH@Z";
SetNavID                                         :: (id: ID, nav_layer: s32, focus_scope_id: ID) #foreign imgui_lib "?SetNavID@ImGui@@YAXIHI@Z";
SetNavIDWithRectRel                              :: (id: ID, nav_layer: s32, focus_scope_id: ID, rect_rel: ImRect) {
    _internal_SetNavIDWithRectRel :: (id: ID, nav_layer: s32, focus_scope_id: ID, rect_rel: *ImRect) #foreign imgui_lib "?SetNavIDWithRectRel@ImGui@@YAXIHIAEBUImRect@@@Z";
    _internal_SetNavIDWithRectRel(id, nav_layer, focus_scope_id, *rect_rel);
}
SetNextItemOpen                                  :: (is_open: bool, cond: Cond = .None) #foreign imgui_lib "?SetNextItemOpen@ImGui@@YAX_NH@Z";
SetNextItemWidth                                 :: (item_width: float) #foreign imgui_lib "?SetNextItemWidth@ImGui@@YAXM@Z";
SetNextWindowBgAlpha                             :: (alpha: float) #foreign imgui_lib "?SetNextWindowBgAlpha@ImGui@@YAXM@Z";
SetNextWindowClass                               :: (window_class: *WindowClass) #foreign imgui_lib "?SetNextWindowClass@ImGui@@YAXPEBUImGuiWindowClass@@@Z";
SetNextWindowCollapsed                           :: (collapsed: bool, cond: Cond = .None) #foreign imgui_lib "?SetNextWindowCollapsed@ImGui@@YAX_NH@Z";
SetNextWindowContentSize                         :: (size: ImVec2) {
    _internal_SetNextWindowContentSize :: (size: *ImVec2) #foreign imgui_lib "?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z";
    _internal_SetNextWindowContentSize(*size);
}
SetNextWindowDockID                              :: (dock_id: ID, cond: Cond = .None) #foreign imgui_lib "?SetNextWindowDockID@ImGui@@YAXIH@Z";
SetNextWindowFocus                               :: () #foreign imgui_lib "?SetNextWindowFocus@ImGui@@YAXXZ";
SetNextWindowPos                                 :: (pos: ImVec2, cond: Cond = .None, pivot: ImVec2 = ImVec2.{0,0}) {
    _internal_SetNextWindowPos :: (pos: *ImVec2, cond: Cond, pivot: *ImVec2) #foreign imgui_lib "?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z";
    _internal_SetNextWindowPos(*pos, cond, *pivot);
}
SetNextWindowScroll                              :: (scroll: ImVec2) {
    _internal_SetNextWindowScroll :: (scroll: *ImVec2) #foreign imgui_lib "?SetNextWindowScroll@ImGui@@YAXAEBUImVec2@@@Z";
    _internal_SetNextWindowScroll(*scroll);
}
SetNextWindowSize                                :: (size: ImVec2, cond: Cond = .None) {
    _internal_SetNextWindowSize :: (size: *ImVec2, cond: Cond) #foreign imgui_lib "?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z";
    _internal_SetNextWindowSize(*size, cond);
}
SetNextWindowSizeConstraints                     :: (size_min: ImVec2, size_max: ImVec2, custom_callback: SizeCallback = null, custom_callback_data: *void = null) {
    _internal_SetNextWindowSizeConstraints :: (size_min: *ImVec2, size_max: *ImVec2, custom_callback: SizeCallback, custom_callback_data: *void) #foreign imgui_lib "?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z";
    _internal_SetNextWindowSizeConstraints(*size_min, *size_max, custom_callback, custom_callback_data);
}
SetNextWindowViewport                            :: (viewport_id: ID) #foreign imgui_lib "?SetNextWindowViewport@ImGui@@YAXI@Z";
SetScrollFromPosX                                :: (local_x: float, center_x_ratio: float = 0.5) #foreign imgui_lib "?SetScrollFromPosX@ImGui@@YAXMM@Z";
SetScrollFromPosX                                :: (window: *Window, local_x: float, center_x_ratio: float) #foreign imgui_lib "?SetScrollFromPosX@ImGui@@YAXPEAUImGuiWindow@@MM@Z";
SetScrollFromPosY                                :: (local_y: float, center_y_ratio: float = 0.5) #foreign imgui_lib "?SetScrollFromPosY@ImGui@@YAXMM@Z";
SetScrollFromPosY                                :: (window: *Window, local_y: float, center_y_ratio: float) #foreign imgui_lib "?SetScrollFromPosY@ImGui@@YAXPEAUImGuiWindow@@MM@Z";
SetScrollHereX                                   :: (center_x_ratio: float = 0.5) #foreign imgui_lib "?SetScrollHereX@ImGui@@YAXM@Z";
SetScrollHereY                                   :: (center_y_ratio: float = 0.5) #foreign imgui_lib "?SetScrollHereY@ImGui@@YAXM@Z";
SetScrollX                                       :: (scroll_x: float) #foreign imgui_lib "?SetScrollX@ImGui@@YAXM@Z";
SetScrollX                                       :: (window: *Window, scroll_x: float) #foreign imgui_lib "?SetScrollX@ImGui@@YAXPEAUImGuiWindow@@M@Z";
SetScrollY                                       :: (scroll_y: float) #foreign imgui_lib "?SetScrollY@ImGui@@YAXM@Z";
SetScrollY                                       :: (window: *Window, scroll_y: float) #foreign imgui_lib "?SetScrollY@ImGui@@YAXPEAUImGuiWindow@@M@Z";
SetStateStorage                                  :: (storage: *Storage) #foreign imgui_lib "?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z";
SetTabItemClosed                                 :: (tab_or_docked_window_label: *u8) #foreign imgui_lib "?SetTabItemClosed@ImGui@@YAXPEBD@Z";
SetTooltip                                       :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?SetTooltip@ImGui@@YAXPEBDZZ";
SetWindowClipRectBeforeSetChannel                :: (window: *Window, clip_rect: ImRect) {
    _internal_SetWindowClipRectBeforeSetChannel :: (window: *Window, clip_rect: *ImRect) #foreign imgui_lib "?SetWindowClipRectBeforeSetChannel@ImGui@@YAXPEAUImGuiWindow@@AEBUImRect@@@Z";
    _internal_SetWindowClipRectBeforeSetChannel(window, *clip_rect);
}
SetWindowCollapsed                               :: (collapsed: bool, cond: Cond = .None) #foreign imgui_lib "?SetWindowCollapsed@ImGui@@YAX_NH@Z";
SetWindowCollapsed                               :: (name: *u8, collapsed: bool, cond: Cond = .None) #foreign imgui_lib "?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z";
SetWindowCollapsed                               :: (window: *Window, collapsed: bool, cond: Cond = .None) #foreign imgui_lib "?SetWindowCollapsed@ImGui@@YAXPEAUImGuiWindow@@_NH@Z";
SetWindowDock                                    :: (window: *Window, dock_id: ID, cond: Cond) #foreign imgui_lib "?SetWindowDock@ImGui@@YAXPEAUImGuiWindow@@IH@Z";
SetWindowFocus                                   :: () #foreign imgui_lib "?SetWindowFocus@ImGui@@YAXXZ";
SetWindowFocus                                   :: (name: *u8) #foreign imgui_lib "?SetWindowFocus@ImGui@@YAXPEBD@Z";
SetWindowFontScale                               :: (scale: float) #foreign imgui_lib "?SetWindowFontScale@ImGui@@YAXM@Z";
SetWindowHitTestHole                             :: (window: *Window, pos: ImVec2, size: ImVec2) {
    _internal_SetWindowHitTestHole :: (window: *Window, pos: *ImVec2, size: *ImVec2) #foreign imgui_lib "?SetWindowHitTestHole@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@1@Z";
    _internal_SetWindowHitTestHole(window, *pos, *size);
}
SetWindowPos                                     :: (pos: ImVec2, cond: Cond = .None) {
    _internal_SetWindowPos :: (pos: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z";
    _internal_SetWindowPos(*pos, cond);
}
SetWindowPos                                     :: (name: *u8, pos: ImVec2, cond: Cond = .None) {
    _internal_SetWindowPos :: (name: *u8, pos: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z";
    _internal_SetWindowPos(name, *pos, cond);
}
SetWindowPos                                     :: (window: *Window, pos: ImVec2, cond: Cond = .None) {
    _internal_SetWindowPos :: (window: *Window, pos: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowPos@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z";
    _internal_SetWindowPos(window, *pos, cond);
}
SetWindowSize                                    :: (size: ImVec2, cond: Cond = .None) {
    _internal_SetWindowSize :: (size: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z";
    _internal_SetWindowSize(*size, cond);
}
SetWindowSize                                    :: (name: *u8, size: ImVec2, cond: Cond = .None) {
    _internal_SetWindowSize :: (name: *u8, size: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z";
    _internal_SetWindowSize(name, *size, cond);
}
SetWindowSize                                    :: (window: *Window, size: ImVec2, cond: Cond = .None) {
    _internal_SetWindowSize :: (window: *Window, size: *ImVec2, cond: Cond) #foreign imgui_lib "?SetWindowSize@ImGui@@YAXPEAUImGuiWindow@@AEBUImVec2@@H@Z";
    _internal_SetWindowSize(window, *size, cond);
}
ShadeVertsLinearColorGradientKeepAlpha           :: (draw_list: *ImDrawList, vert_start_idx: s32, vert_end_idx: s32, gradient_p0: ImVec2, gradient_p1: ImVec2, col0: u32, col1: u32) #foreign imgui_lib "?ShadeVertsLinearColorGradientKeepAlpha@ImGui@@YAXPEAUImDrawList@@HHUImVec2@@1II@Z";
ShadeVertsLinearUV                               :: (draw_list: *ImDrawList, vert_start_idx: s32, vert_end_idx: s32, a: ImVec2, b: ImVec2, uv_a: ImVec2, uv_b: ImVec2, clamp: bool) {
    _internal_ShadeVertsLinearUV :: (draw_list: *ImDrawList, vert_start_idx: s32, vert_end_idx: s32, a: *ImVec2, b: *ImVec2, uv_a: *ImVec2, uv_b: *ImVec2, clamp: bool) #foreign imgui_lib "?ShadeVertsLinearUV@ImGui@@YAXPEAUImDrawList@@HHAEBUImVec2@@111_N@Z";
    _internal_ShadeVertsLinearUV(draw_list, vert_start_idx, vert_end_idx, *a, *b, *uv_a, *uv_b, clamp);
}
ShowAboutWindow                                  :: (p_open: *bool = null) #foreign imgui_lib "?ShowAboutWindow@ImGui@@YAXPEA_N@Z";
ShowDemoWindow                                   :: (p_open: *bool = null) #foreign imgui_lib "?ShowDemoWindow@ImGui@@YAXPEA_N@Z";
ShowFontSelector                                 :: (label: *u8) #foreign imgui_lib "?ShowFontSelector@ImGui@@YAXPEBD@Z";
ShowMetricsWindow                                :: (p_open: *bool = null) #foreign imgui_lib "?ShowMetricsWindow@ImGui@@YAXPEA_N@Z";
ShowStyleEditor                                  :: (ref: *Style = null) #foreign imgui_lib "?ShowStyleEditor@ImGui@@YAXPEAUImGuiStyle@@@Z";
ShowStyleSelector                                :: (label: *u8) -> bool #foreign imgui_lib "?ShowStyleSelector@ImGui@@YA_NPEBD@Z";
ShowUserGuide                                    :: () #foreign imgui_lib "?ShowUserGuide@ImGui@@YAXXZ";
ShrinkWidths                                     :: (items: *ShrinkWidthItem, count: s32, width_excess: float) #foreign imgui_lib "?ShrinkWidths@ImGui@@YAXPEAUImGuiShrinkWidthItem@@HM@Z";
Shutdown                                         :: (ctx: *Context) #foreign imgui_lib "?Shutdown@ImGui@@YAXPEAUImGuiContext@@@Z";
SliderAngle                                      :: (label: *u8, v_rad: *float, v_degrees_min: float = 360.0, v_degrees_max: float = 360.0, format: *u8 = "%.0f deg", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderAngle@ImGui@@YA_NPEBDPEAMMM0H@Z";
SliderBehavior                                   :: (bb: ImRect, id: ID, data_type: DataType, p_v: *void, p_min: *void, p_max: *void, format: *u8, flags: SliderFlags, out_grab_bb: *ImRect) -> bool {
    _internal_SliderBehavior :: (bb: *ImRect, id: ID, data_type: DataType, p_v: *void, p_min: *void, p_max: *void, format: *u8, flags: SliderFlags, out_grab_bb: *ImRect) -> bool #foreign imgui_lib "?SliderBehavior@ImGui@@YA_NAEBUImRect@@IHPEAXPEBX2PEBDHPEAU2@@Z";
    return _internal_SliderBehavior(*bb, id, data_type, p_v, p_min, p_max, format, flags, out_grab_bb);
}
SliderFloat                                      :: (label: *u8, v: *float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z";
SliderFloat2                                     :: (label: *u8, v: [2]float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0H@Z";
SliderFloat3                                     :: (label: *u8, v: [3]float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0H@Z";
SliderFloat4                                     :: (label: *u8, v: [4]float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0H@Z";
SliderInt                                        :: (label: *u8, v: *s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderInt@ImGui@@YA_NPEBDPEAHHH0H@Z";
SliderInt2                                       :: (label: *u8, v: [2]s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderInt2@ImGui@@YA_NPEBDQEAHHH0H@Z";
SliderInt3                                       :: (label: *u8, v: [3]s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderInt3@ImGui@@YA_NPEBDQEAHHH0H@Z";
SliderInt4                                       :: (label: *u8, v: [4]s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderInt4@ImGui@@YA_NPEBDQEAHHH0H@Z";
SliderScalar                                     :: (label: *u8, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z";
SliderScalarN                                    :: (label: *u8, data_type: DataType, p_data: *void, components: s32, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui_lib "?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z";
SmallButton                                      :: (label: *u8) -> bool #foreign imgui_lib "?SmallButton@ImGui@@YA_NPEBD@Z";
Spacing                                          :: () #foreign imgui_lib "?Spacing@ImGui@@YAXXZ";
StartMouseMovingWindow                           :: (window: *Window) #foreign imgui_lib "?StartMouseMovingWindow@ImGui@@YAXPEAUImGuiWindow@@@Z";
StartMouseMovingWindowOrNode                     :: (window: *Window, node: *DockNode, undock_floating_node: bool) #foreign imgui_lib "?StartMouseMovingWindowOrNode@ImGui@@YAXPEAUImGuiWindow@@PEAUImGuiDockNode@@_N@Z";
StyleColorsClassic                               :: (dst: *Style = null) #foreign imgui_lib "?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z";
StyleColorsDark                                  :: (dst: *Style = null) #foreign imgui_lib "?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z";
StyleColorsLight                                 :: (dst: *Style = null) #foreign imgui_lib "?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z";
TabBarAddTab                                     :: (tab_bar: *TabBar, tab_flags: TabItemFlags, window: *Window) #foreign imgui_lib "?TabBarAddTab@ImGui@@YAXPEAUImGuiTabBar@@HPEAUImGuiWindow@@@Z";
TabBarCloseTab                                   :: (tab_bar: *TabBar, tab: *TabItem) #foreign imgui_lib "?TabBarCloseTab@ImGui@@YAXPEAUImGuiTabBar@@PEAUImGuiTabItem@@@Z";
TabBarFindMostRecentlySelectedTabForActiveWindow :: (tab_bar: *TabBar) -> *TabItem #foreign imgui_lib "?TabBarFindMostRecentlySelectedTabForActiveWindow@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@@Z";
TabBarFindTabByID                                :: (tab_bar: *TabBar, tab_id: ID) -> *TabItem #foreign imgui_lib "?TabBarFindTabByID@ImGui@@YAPEAUImGuiTabItem@@PEAUImGuiTabBar@@I@Z";
TabBarProcessReorder                             :: (tab_bar: *TabBar) -> bool #foreign imgui_lib "?TabBarProcessReorder@ImGui@@YA_NPEAUImGuiTabBar@@@Z";
TabBarQueueReorder                               :: (tab_bar: *TabBar, tab: *TabItem, dir: s32) #foreign imgui_lib "?TabBarQueueReorder@ImGui@@YAXPEAUImGuiTabBar@@PEBUImGuiTabItem@@H@Z";
TabBarRemoveTab                                  :: (tab_bar: *TabBar, tab_id: ID) #foreign imgui_lib "?TabBarRemoveTab@ImGui@@YAXPEAUImGuiTabBar@@I@Z";
TabItemBackground                                :: (draw_list: *ImDrawList, bb: ImRect, flags: TabItemFlags, col: u32) {
    _internal_TabItemBackground :: (draw_list: *ImDrawList, bb: *ImRect, flags: TabItemFlags, col: u32) #foreign imgui_lib "?TabItemBackground@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HI@Z";
    _internal_TabItemBackground(draw_list, *bb, flags, col);
}
TabItemButton                                    :: (label: *u8, flags: TabItemFlags = .None) -> bool #foreign imgui_lib "?TabItemButton@ImGui@@YA_NPEBDH@Z";
TabItemEx                                        :: (tab_bar: *TabBar, label: *u8, p_open: *bool, flags: TabItemFlags, docked_window: *Window) -> bool #foreign imgui_lib "?TabItemEx@ImGui@@YA_NPEAUImGuiTabBar@@PEBDPEA_NHPEAUImGuiWindow@@@Z";
TabItemLabelAndCloseButton                       :: (draw_list: *ImDrawList, bb: ImRect, flags: TabItemFlags, frame_padding: ImVec2, label: *u8, tab_id: ID, close_button_id: ID, is_contents_visible: bool, out_just_closed: *bool, out_text_clipped: *bool) {
    _internal_TabItemLabelAndCloseButton :: (draw_list: *ImDrawList, bb: *ImRect, flags: TabItemFlags, frame_padding: ImVec2, label: *u8, tab_id: ID, close_button_id: ID, is_contents_visible: bool, out_just_closed: *bool, out_text_clipped: *bool) #foreign imgui_lib "?TabItemLabelAndCloseButton@ImGui@@YAXPEAUImDrawList@@AEBUImRect@@HUImVec2@@PEBDII_NPEA_N5@Z";
    _internal_TabItemLabelAndCloseButton(draw_list, *bb, flags, frame_padding, label, tab_id, close_button_id, is_contents_visible, out_just_closed, out_text_clipped);
}
TableBeginApplyRequests                          :: (table: *Table) #foreign imgui_lib "?TableBeginApplyRequests@ImGui@@YAXPEAUImGuiTable@@@Z";
TableBeginCell                                   :: (table: *Table, column_n: s32) #foreign imgui_lib "?TableBeginCell@ImGui@@YAXPEAUImGuiTable@@H@Z";
TableBeginInitMemory                             :: (table: *Table, columns_count: s32) #foreign imgui_lib "?TableBeginInitMemory@ImGui@@YAXPEAUImGuiTable@@H@Z";
TableBeginRow                                    :: (table: *Table) #foreign imgui_lib "?TableBeginRow@ImGui@@YAXPEAUImGuiTable@@@Z";
TableDrawBorders                                 :: (table: *Table) #foreign imgui_lib "?TableDrawBorders@ImGui@@YAXPEAUImGuiTable@@@Z";
TableDrawContextMenu                             :: (table: *Table) #foreign imgui_lib "?TableDrawContextMenu@ImGui@@YAXPEAUImGuiTable@@@Z";
TableEndCell                                     :: (table: *Table) #foreign imgui_lib "?TableEndCell@ImGui@@YAXPEAUImGuiTable@@@Z";
TableEndRow                                      :: (table: *Table) #foreign imgui_lib "?TableEndRow@ImGui@@YAXPEAUImGuiTable@@@Z";
TableFindByID                                    :: (id: ID) -> *Table #foreign imgui_lib "?TableFindByID@ImGui@@YAPEAUImGuiTable@@I@Z";
TableFixColumnSortDirection                      :: (table: *Table, column: *TableColumn) #foreign imgui_lib "?TableFixColumnSortDirection@ImGui@@YAXPEAUImGuiTable@@PEAUImGuiTableColumn@@@Z";
TableGcCompactSettings                           :: () #foreign imgui_lib "?TableGcCompactSettings@ImGui@@YAXXZ";
TableGcCompactTransientBuffers                   :: (table: *Table) #foreign imgui_lib "?TableGcCompactTransientBuffers@ImGui@@YAXPEAUImGuiTable@@@Z";
TableGetBoundSettings                            :: (table: *Table) -> *TableSettings #foreign imgui_lib "?TableGetBoundSettings@ImGui@@YAPEAUImGuiTableSettings@@PEAUImGuiTable@@@Z";
TableGetColumnCount                              :: () -> s32 #foreign imgui_lib "?TableGetColumnCount@ImGui@@YAHXZ";
TableGetColumnFlags                              :: (column_n: s32 = -1) -> TableColumnFlags #foreign imgui_lib "?TableGetColumnFlags@ImGui@@YAHH@Z";
TableGetColumnIndex                              :: () -> s32 #foreign imgui_lib "?TableGetColumnIndex@ImGui@@YAHXZ";
TableGetColumnName                               :: (column_n: s32 = -1) -> *u8 #foreign imgui_lib "?TableGetColumnName@ImGui@@YAPEBDH@Z";
TableGetColumnName                               :: (table: *Table, column_n: s32) -> *u8 #foreign imgui_lib "?TableGetColumnName@ImGui@@YAPEBDPEBUImGuiTable@@H@Z";
TableGetColumnNextSortDirection                  :: (column: *TableColumn) -> SortDirection #foreign imgui_lib "?TableGetColumnNextSortDirection@ImGui@@YAHPEAUImGuiTableColumn@@@Z";
TableGetColumnResizeID                           :: (table: *Table, column_n: s32, instance_no: s32 = 0) -> ID #foreign imgui_lib "?TableGetColumnResizeID@ImGui@@YAIPEBUImGuiTable@@HH@Z";
TableGetHeaderRowHeight                          :: () -> float #foreign imgui_lib "?TableGetHeaderRowHeight@ImGui@@YAMXZ";
TableGetHoveredColumn                            :: () -> s32 #foreign imgui_lib "?TableGetHoveredColumn@ImGui@@YAHXZ";
TableGetMinColumnWidth                           :: () -> float #foreign imgui_lib "?TableGetMinColumnWidth@ImGui@@YAMXZ";
TableGetRowIndex                                 :: () -> s32 #foreign imgui_lib "?TableGetRowIndex@ImGui@@YAHXZ";
TableGetSortSpecs                                :: () -> *TableSortSpecs #foreign imgui_lib "?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ";
TableHeader                                      :: (label: *u8) #foreign imgui_lib "?TableHeader@ImGui@@YAXPEBD@Z";
TableHeadersRow                                  :: () #foreign imgui_lib "?TableHeadersRow@ImGui@@YAXXZ";
TableLoadSettings                                :: (table: *Table) #foreign imgui_lib "?TableLoadSettings@ImGui@@YAXPEAUImGuiTable@@@Z";
TableMergeDrawChannels                           :: (table: *Table) #foreign imgui_lib "?TableMergeDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z";
TableNextColumn                                  :: () -> bool #foreign imgui_lib "?TableNextColumn@ImGui@@YA_NXZ";
TableNextRow                                     :: (row_flags: TableRowFlags = .None, min_row_height: float = 0.0) #foreign imgui_lib "?TableNextRow@ImGui@@YAXHM@Z";
TableOpenContextMenu                             :: (column_n: s32 = -1) #foreign imgui_lib "?TableOpenContextMenu@ImGui@@YAXH@Z";
TablePopBackgroundChannel                        :: () #foreign imgui_lib "?TablePopBackgroundChannel@ImGui@@YAXXZ";
TablePushBackgroundChannel                       :: () #foreign imgui_lib "?TablePushBackgroundChannel@ImGui@@YAXXZ";
TableRemove                                      :: (table: *Table) #foreign imgui_lib "?TableRemove@ImGui@@YAXPEAUImGuiTable@@@Z";
TableResetSettings                               :: (table: *Table) #foreign imgui_lib "?TableResetSettings@ImGui@@YAXPEAUImGuiTable@@@Z";
TableSaveSettings                                :: (table: *Table) #foreign imgui_lib "?TableSaveSettings@ImGui@@YAXPEAUImGuiTable@@@Z";
TableSetBgColor                                  :: (bg_target: TableBgTarget, color: u32, column_n: s32 = -1) #foreign imgui_lib "?TableSetBgColor@ImGui@@YAXHIH@Z";
TableSetColumnIndex                              :: (column_n: s32) -> bool #foreign imgui_lib "?TableSetColumnIndex@ImGui@@YA_NH@Z";
TableSetColumnSortDirection                      :: (column_n: s32, sort_direction: SortDirection, append_to_sort_specs: bool) #foreign imgui_lib "?TableSetColumnSortDirection@ImGui@@YAXHH_N@Z";
TableSetColumnWidth                              :: (column_n: s32, width: float) #foreign imgui_lib "?TableSetColumnWidth@ImGui@@YAXHM@Z";
TableSetColumnWidthAutoAll                       :: (table: *Table) #foreign imgui_lib "?TableSetColumnWidthAutoAll@ImGui@@YAXPEAUImGuiTable@@@Z";
TableSetColumnWidthAutoSingle                    :: (table: *Table, column_n: s32) #foreign imgui_lib "?TableSetColumnWidthAutoSingle@ImGui@@YAXPEAUImGuiTable@@H@Z";
TableSettingsCreate                              :: (id: ID, columns_count: s32) -> *TableSettings #foreign imgui_lib "?TableSettingsCreate@ImGui@@YAPEAUImGuiTableSettings@@IH@Z";
TableSettingsFindByID                            :: (id: ID) -> *TableSettings #foreign imgui_lib "?TableSettingsFindByID@ImGui@@YAPEAUImGuiTableSettings@@I@Z";
TableSettingsInstallHandler                      :: (ctx: *Context) #foreign imgui_lib "?TableSettingsInstallHandler@ImGui@@YAXPEAUImGuiContext@@@Z";
TableSetupColumn                                 :: (label: *u8, flags: TableColumnFlags = .None, init_width_or_weight: float = 1.0, user_id: u32 = 0) #foreign imgui_lib "?TableSetupColumn@ImGui@@YAXPEBDHMI@Z";
TableSetupDrawChannels                           :: (table: *Table) #foreign imgui_lib "?TableSetupDrawChannels@ImGui@@YAXPEAUImGuiTable@@@Z";
TableSetupScrollFreeze                           :: (cols: s32, rows: s32) #foreign imgui_lib "?TableSetupScrollFreeze@ImGui@@YAXHH@Z";
TableSortSpecsBuild                              :: (table: *Table) #foreign imgui_lib "?TableSortSpecsBuild@ImGui@@YAXPEAUImGuiTable@@@Z";
TableSortSpecsSanitize                           :: (table: *Table) #foreign imgui_lib "?TableSortSpecsSanitize@ImGui@@YAXPEAUImGuiTable@@@Z";
TableUpdateBorders                               :: (table: *Table) #foreign imgui_lib "?TableUpdateBorders@ImGui@@YAXPEAUImGuiTable@@@Z";
TableUpdateColumnsWeightFromWidth                :: (table: *Table) #foreign imgui_lib "?TableUpdateColumnsWeightFromWidth@ImGui@@YAXPEAUImGuiTable@@@Z";
TableUpdateLayout                                :: (table: *Table) #foreign imgui_lib "?TableUpdateLayout@ImGui@@YAXPEAUImGuiTable@@@Z";
TempInputScalar                                  :: (bb: ImRect, id: ID, label: *u8, data_type: DataType, p_data: *void, format: *u8, p_clamp_min: *void = null, p_clamp_max: *void = null) -> bool {
    _internal_TempInputScalar :: (bb: *ImRect, id: ID, label: *u8, data_type: DataType, p_data: *void, format: *u8, p_clamp_min: *void, p_clamp_max: *void) -> bool #foreign imgui_lib "?TempInputScalar@ImGui@@YA_NAEBUImRect@@IPEBDHPEAX1PEBX3@Z";
    return _internal_TempInputScalar(*bb, id, label, data_type, p_data, format, p_clamp_min, p_clamp_max);
}
TempInputText                                    :: (bb: ImRect, id: ID, label: *u8, buf: *u8, buf_size: s32, flags: InputTextFlags) -> bool {
    _internal_TempInputText :: (bb: *ImRect, id: ID, label: *u8, buf: *u8, buf_size: s32, flags: InputTextFlags) -> bool #foreign imgui_lib "?TempInputText@ImGui@@YA_NAEBUImRect@@IPEBDPEADHH@Z";
    return _internal_TempInputText(*bb, id, label, buf, buf_size, flags);
}
Text                                             :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?Text@ImGui@@YAXPEBDZZ";
TextColored                                      :: (col: ImVec4, fmt: *u8, args: ..Any) {
    _internal_TextColored :: (col: *ImVec4, fmt: *u8, args: ..Any) #foreign imgui_lib "?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ";
    _internal_TextColored(*col, fmt, args);
}
TextDisabled                                     :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?TextDisabled@ImGui@@YAXPEBDZZ";
TextEx                                           :: (text: string, flags: TextFlags = .None) {
    _internal_TextEx :: (text: *u8, text_end: *u8, flags: TextFlags) #foreign imgui_lib "?TextEx@ImGui@@YAXPEBD0H@Z";
    _internal_TextEx(text.data, text.data + text.count, flags);
}
TextUnformatted                                  :: (text: string) {
    _internal_TextUnformatted :: (text: *u8, text_end: *u8) #foreign imgui_lib "?TextUnformatted@ImGui@@YAXPEBD0@Z";
    _internal_TextUnformatted(text.data, text.data + text.count);
}
TextWrapped                                      :: (fmt: *u8, args: ..Any) #foreign imgui_lib "?TextWrapped@ImGui@@YAXPEBDZZ";
TranslateWindowsInViewport                       :: (viewport: *ViewportP, old_pos: ImVec2, new_pos: ImVec2) {
    _internal_TranslateWindowsInViewport :: (viewport: *ViewportP, old_pos: *ImVec2, new_pos: *ImVec2) #foreign imgui_lib "?TranslateWindowsInViewport@ImGui@@YAXPEAUImGuiViewportP@@AEBUImVec2@@1@Z";
    _internal_TranslateWindowsInViewport(viewport, *old_pos, *new_pos);
}
TreeNode                                         :: (label: *u8) -> bool #foreign imgui_lib "?TreeNode@ImGui@@YA_NPEBD@Z";
TreeNode                                         :: (str_id: *u8, fmt: *u8, args: ..Any) -> bool #foreign imgui_lib "?TreeNode@ImGui@@YA_NPEBD0ZZ";
TreeNode                                         :: (ptr_id: *void, fmt: *u8, args: ..Any) -> bool #foreign imgui_lib "?TreeNode@ImGui@@YA_NPEBXPEBDZZ";
TreeNodeBehavior                                 :: (id: ID, flags: TreeNodeFlags, label: string) -> bool {
    _internal_TreeNodeBehavior :: (id: ID, flags: TreeNodeFlags, label: *u8, label_end: *u8) -> bool #foreign imgui_lib "?TreeNodeBehavior@ImGui@@YA_NIHPEBD0@Z";
    return _internal_TreeNodeBehavior(id, flags, label.data, label.data + label.count);
}
TreeNodeBehaviorIsOpen                           :: (id: ID, flags: TreeNodeFlags = .None) -> bool #foreign imgui_lib "?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z";
TreeNodeEx                                       :: (label: *u8, flags: TreeNodeFlags = .None) -> bool #foreign imgui_lib "?TreeNodeEx@ImGui@@YA_NPEBDH@Z";
TreeNodeEx                                       :: (str_id: *u8, flags: TreeNodeFlags, fmt: *u8, args: ..Any) -> bool #foreign imgui_lib "?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ";
TreeNodeEx                                       :: (ptr_id: *void, flags: TreeNodeFlags, fmt: *u8, args: ..Any) -> bool #foreign imgui_lib "?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ";
TreePop                                          :: () #foreign imgui_lib "?TreePop@ImGui@@YAXXZ";
TreePush                                         :: (str_id: *u8) #foreign imgui_lib "?TreePush@ImGui@@YAXPEBD@Z";
TreePush                                         :: (ptr_id: *void = null) #foreign imgui_lib "?TreePush@ImGui@@YAXPEBX@Z";
TreePushOverrideID                               :: (id: ID) #foreign imgui_lib "?TreePushOverrideID@ImGui@@YAXI@Z";
Unindent                                         :: (indent_w: float = 0.0) #foreign imgui_lib "?Unindent@ImGui@@YAXM@Z";
UpdateHoveredWindowAndCaptureFlags               :: () #foreign imgui_lib "?UpdateHoveredWindowAndCaptureFlags@ImGui@@YAXXZ";
UpdateMouseMovingWindowEndFrame                  :: () #foreign imgui_lib "?UpdateMouseMovingWindowEndFrame@ImGui@@YAXXZ";
UpdateMouseMovingWindowNewFrame                  :: () #foreign imgui_lib "?UpdateMouseMovingWindowNewFrame@ImGui@@YAXXZ";
UpdatePlatformWindows                            :: () #foreign imgui_lib "?UpdatePlatformWindows@ImGui@@YAXXZ";
UpdateWindowParentAndRootLinks                   :: (window: *Window, flags: WindowFlags, parent_window: *Window) #foreign imgui_lib "?UpdateWindowParentAndRootLinks@ImGui@@YAXPEAUImGuiWindow@@H0@Z";
VSliderFloat                                     :: (label: *u8, size: ImVec2, v: *float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool {
    _internal_VSliderFloat :: (label: *u8, size: *ImVec2, v: *float, v_min: float, v_max: float, format: *u8, flags: SliderFlags) -> bool #foreign imgui_lib "?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0H@Z";
    return _internal_VSliderFloat(label, *size, v, v_min, v_max, format, flags);
}
VSliderInt                                       :: (label: *u8, size: ImVec2, v: *s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool {
    _internal_VSliderInt :: (label: *u8, size: *ImVec2, v: *s32, v_min: s32, v_max: s32, format: *u8, flags: SliderFlags) -> bool #foreign imgui_lib "?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0H@Z";
    return _internal_VSliderInt(label, *size, v, v_min, v_max, format, flags);
}
VSliderScalar                                    :: (label: *u8, size: ImVec2, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool {
    _internal_VSliderScalar :: (label: *u8, size: *ImVec2, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8, flags: SliderFlags) -> bool #foreign imgui_lib "?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30H@Z";
    return _internal_VSliderScalar(label, *size, data_type, p_data, p_min, p_max, format, flags);
}
Value                                            :: (prefix: *u8, b: bool) #foreign imgui_lib "?Value@ImGui@@YAXPEBD_N@Z";
Value                                            :: (prefix: *u8, v: s32) #foreign imgui_lib "?Value@ImGui@@YAXPEBDH@Z";
Value                                            :: (prefix: *u8, v: u32) #foreign imgui_lib "?Value@ImGui@@YAXPEBDI@Z";
Value                                            :: (prefix: *u8, v: float, float_format: *u8 = null) #foreign imgui_lib "?Value@ImGui@@YAXPEBDM0@Z";

//
// section: STRUCTS
//

ImBitVector :: struct {
    Storage: ImVector(u32);

    Clear        :: (self: *ImBitVector) #foreign imgui_lib "?Clear@ImBitVector@@QEAAXXZ";
    ClearBit     :: (self: *ImBitVector, n: s32) #foreign imgui_lib "?ClearBit@ImBitVector@@QEAAXH@Z";
    Create       :: (self: *ImBitVector, sz: s32) #foreign imgui_lib "?Create@ImBitVector@@QEAAXH@Z";
    SetBit       :: (self: *ImBitVector, n: s32) #foreign imgui_lib "?SetBit@ImBitVector@@QEAAXH@Z";
    TestBit      :: (self: *ImBitVector, n: s32) -> bool #foreign imgui_lib "?TestBit@ImBitVector@@QEBA_NH@Z";
}

ImColor :: struct {
    Value: ImVec4;
}

ImDrawChannel :: struct {
    _CmdBuffer: ImVector(ImDrawCmd);
    _IdxBuffer: ImVector(ImDrawIdx);
}

ImDrawCmd :: struct {
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: u32;
    IdxOffset: u32;
    ElemCount: u32;
    UserCallback: ImDrawCallback;
    UserCallbackData: *void;
}

ImDrawCmdHeader :: struct {
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: u32;
}

ImDrawData :: struct {
    Valid: bool;
    CmdLists: **ImDrawList;
    CmdListsCount: s32;
    TotalIdxCount: s32;
    TotalVtxCount: s32;
    DisplayPos: ImVec2;
    DisplaySize: ImVec2;
    FramebufferScale: ImVec2;
    OwnerViewport: *Viewport;

    DeIndexAllBuffers     :: (self: *ImDrawData) #foreign imgui_lib "?DeIndexAllBuffers@ImDrawData@@QEAAXXZ";
    ScaleClipRects        :: (self: *ImDrawData, fb_scale: ImVec2) {
    _internal_ScaleClipRects :: (self: *ImDrawData, fb_scale: *ImVec2) #foreign imgui_lib "?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z";
    _internal_ScaleClipRects(self, *fb_scale);
}
}

ImDrawDataBuilder :: struct {
    Layers: [2]ImVector(*ImDrawList);

    FlattenIntoSingleLayer     :: (self: *ImDrawDataBuilder) #foreign imgui_lib "?FlattenIntoSingleLayer@ImDrawDataBuilder@@QEAAXXZ";
}

ImDrawList :: struct {
    CmdBuffer: ImVector(ImDrawCmd);
    IdxBuffer: ImVector(ImDrawIdx);
    VtxBuffer: ImVector(ImDrawVert);
    Flags: ImDrawListFlags;
    _VtxCurrentIdx: u32;
    _Data: *ImDrawListSharedData;
    _OwnerName: *u8;
    _VtxWritePtr: *ImDrawVert;
    _IdxWritePtr: *ImDrawIdx;
    _ClipRectStack: ImVector(ImVec4);
    _TextureIdStack: ImVector(ImTextureID);
    _Path: ImVector(ImVec2);
    _CmdHeader: ImDrawCmdHeader;
    _Splitter: ImDrawListSplitter;

    AddBezierCurve              :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: u32, thickness: float, num_segments: s32 = 0) {
    _internal_AddBezierCurve :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: u32, thickness: float, num_segments: s32) #foreign imgui_lib "?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z";
    _internal_AddBezierCurve(self, *p1, *p2, *p3, *p4, col, thickness, num_segments);
}
    AddCircle                   :: (self: *ImDrawList, center: ImVec2, radius: float, col: u32, num_segments: s32 = 0, thickness: float = 1.0) {
    _internal_AddCircle :: (self: *ImDrawList, center: *ImVec2, radius: float, col: u32, num_segments: s32, thickness: float) #foreign imgui_lib "?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z";
    _internal_AddCircle(self, *center, radius, col, num_segments, thickness);
}
    AddCircleFilled             :: (self: *ImDrawList, center: ImVec2, radius: float, col: u32, num_segments: s32 = 0) {
    _internal_AddCircleFilled :: (self: *ImDrawList, center: *ImVec2, radius: float, col: u32, num_segments: s32) #foreign imgui_lib "?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z";
    _internal_AddCircleFilled(self, *center, radius, col, num_segments);
}
    AddConvexPolyFilled         :: (self: *ImDrawList, points: *ImVec2, num_points: s32, col: u32) #foreign imgui_lib "?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z";
    AddDrawCmd                  :: (self: *ImDrawList) #foreign imgui_lib "?AddDrawCmd@ImDrawList@@QEAAXXZ";
    AddImage                    :: (self: *ImDrawList, user_texture_id: ImTextureID, p_min: ImVec2, p_max: ImVec2, uv_min: ImVec2 = ImVec2.{0,0}, uv_max: ImVec2 = ImVec2.{1,1}, col: u32 = 4294967295) {
    _internal_AddImage :: (self: *ImDrawList, user_texture_id: ImTextureID, p_min: *ImVec2, p_max: *ImVec2, uv_min: *ImVec2, uv_max: *ImVec2, col: u32) #foreign imgui_lib "?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z";
    _internal_AddImage(self, user_texture_id, *p_min, *p_max, *uv_min, *uv_max, col);
}
    AddImageQuad                :: (self: *ImDrawList, user_texture_id: ImTextureID, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, uv1: ImVec2 = ImVec2.{0,0}, uv2: ImVec2 = ImVec2.{1,0}, uv3: ImVec2 = ImVec2.{1,1}, uv4: ImVec2 = ImVec2.{0,1}, col: u32 = 4294967295) {
    _internal_AddImageQuad :: (self: *ImDrawList, user_texture_id: ImTextureID, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, uv1: *ImVec2, uv2: *ImVec2, uv3: *ImVec2, uv4: *ImVec2, col: u32) #foreign imgui_lib "?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z";
    _internal_AddImageQuad(self, user_texture_id, *p1, *p2, *p3, *p4, *uv1, *uv2, *uv3, *uv4, col);
}
    AddImageRounded             :: (self: *ImDrawList, user_texture_id: ImTextureID, p_min: ImVec2, p_max: ImVec2, uv_min: ImVec2, uv_max: ImVec2, col: u32, rounding: float, rounding_corners: ImDrawCornerFlags = .All) {
    _internal_AddImageRounded :: (self: *ImDrawList, user_texture_id: ImTextureID, p_min: *ImVec2, p_max: *ImVec2, uv_min: *ImVec2, uv_max: *ImVec2, col: u32, rounding: float, rounding_corners: ImDrawCornerFlags) #foreign imgui_lib "?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z";
    _internal_AddImageRounded(self, user_texture_id, *p_min, *p_max, *uv_min, *uv_max, col, rounding, rounding_corners);
}
    AddLine                     :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, col: u32, thickness: float = 1.0) {
    _internal_AddLine :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, col: u32, thickness: float) #foreign imgui_lib "?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z";
    _internal_AddLine(self, *p1, *p2, col, thickness);
}
    AddNgon                     :: (self: *ImDrawList, center: ImVec2, radius: float, col: u32, num_segments: s32, thickness: float = 1.0) {
    _internal_AddNgon :: (self: *ImDrawList, center: *ImVec2, radius: float, col: u32, num_segments: s32, thickness: float) #foreign imgui_lib "?AddNgon@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z";
    _internal_AddNgon(self, *center, radius, col, num_segments, thickness);
}
    AddNgonFilled               :: (self: *ImDrawList, center: ImVec2, radius: float, col: u32, num_segments: s32) {
    _internal_AddNgonFilled :: (self: *ImDrawList, center: *ImVec2, radius: float, col: u32, num_segments: s32) #foreign imgui_lib "?AddNgonFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z";
    _internal_AddNgonFilled(self, *center, radius, col, num_segments);
}
    AddPolyline                 :: (self: *ImDrawList, points: *ImVec2, num_points: s32, col: u32, closed: bool, thickness: float) #foreign imgui_lib "?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HI_NM@Z";
    AddQuad                     :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: u32, thickness: float = 1.0) {
    _internal_AddQuad :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: u32, thickness: float) #foreign imgui_lib "?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z";
    _internal_AddQuad(self, *p1, *p2, *p3, *p4, col, thickness);
}
    AddQuadFilled               :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: u32) {
    _internal_AddQuadFilled :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: u32) #foreign imgui_lib "?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z";
    _internal_AddQuadFilled(self, *p1, *p2, *p3, *p4, col);
}
    AddRect                     :: (self: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col: u32, rounding: float = 0.0, rounding_corners: ImDrawCornerFlags = .All, thickness: float = 1.0) {
    _internal_AddRect :: (self: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col: u32, rounding: float, rounding_corners: ImDrawCornerFlags, thickness: float) #foreign imgui_lib "?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z";
    _internal_AddRect(self, *p_min, *p_max, col, rounding, rounding_corners, thickness);
}
    AddRectFilled               :: (self: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col: u32, rounding: float = 0.0, rounding_corners: ImDrawCornerFlags = .All) {
    _internal_AddRectFilled :: (self: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col: u32, rounding: float, rounding_corners: ImDrawCornerFlags) #foreign imgui_lib "?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z";
    _internal_AddRectFilled(self, *p_min, *p_max, col, rounding, rounding_corners);
}
    AddRectFilledMultiColor     :: (self: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col_upr_left: u32, col_upr_right: u32, col_bot_right: u32, col_bot_left: u32) {
    _internal_AddRectFilledMultiColor :: (self: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col_upr_left: u32, col_upr_right: u32, col_bot_right: u32, col_bot_left: u32) #foreign imgui_lib "?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z";
    _internal_AddRectFilledMultiColor(self, *p_min, *p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
}
    AddText                     :: (self: *ImDrawList, pos: ImVec2, col: u32, text: string) {
    _internal_AddText :: (self: *ImDrawList, pos: *ImVec2, col: u32, text_begin: *u8, text_end: *u8) #foreign imgui_lib "?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z";
    _internal_AddText(self, *pos, col, text.data, text.data + text.count);
}
    AddText                     :: (self: *ImDrawList, font: *ImFont, font_size: float, pos: ImVec2, col: u32, text: string, wrap_width: float = 0.0, cpu_fine_clip_rect: *ImVec4 = null) {
    _internal_AddText :: (self: *ImDrawList, font: *ImFont, font_size: float, pos: *ImVec2, col: u32, text_begin: *u8, text_end: *u8, wrap_width: float, cpu_fine_clip_rect: *ImVec4) #foreign imgui_lib "?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z";
    _internal_AddText(self, font, font_size, *pos, col, text.data, text.data + text.count, wrap_width, cpu_fine_clip_rect);
}
    AddTriangle                 :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, col: u32, thickness: float = 1.0) {
    _internal_AddTriangle :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, col: u32, thickness: float) #foreign imgui_lib "?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z";
    _internal_AddTriangle(self, *p1, *p2, *p3, col, thickness);
}
    AddTriangleFilled           :: (self: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, col: u32) {
    _internal_AddTriangleFilled :: (self: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, col: u32) #foreign imgui_lib "?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z";
    _internal_AddTriangleFilled(self, *p1, *p2, *p3, col);
}
    CloneOutput                 :: (self: *ImDrawList) -> *ImDrawList #foreign imgui_lib "?CloneOutput@ImDrawList@@QEBAPEAU1@XZ";
    PathArcTo                   :: (self: *ImDrawList, center: ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32 = 10) {
    _internal_PathArcTo :: (self: *ImDrawList, center: *ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32) #foreign imgui_lib "?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z";
    _internal_PathArcTo(self, *center, radius, a_min, a_max, num_segments);
}
    PathArcToFast               :: (self: *ImDrawList, center: ImVec2, radius: float, a_min_of_12: s32, a_max_of_12: s32) {
    _internal_PathArcToFast :: (self: *ImDrawList, center: *ImVec2, radius: float, a_min_of_12: s32, a_max_of_12: s32) #foreign imgui_lib "?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z";
    _internal_PathArcToFast(self, *center, radius, a_min_of_12, a_max_of_12);
}
    PathBezierCurveTo           :: (self: *ImDrawList, p2: ImVec2, p3: ImVec2, p4: ImVec2, num_segments: s32 = 0) {
    _internal_PathBezierCurveTo :: (self: *ImDrawList, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, num_segments: s32) #foreign imgui_lib "?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z";
    _internal_PathBezierCurveTo(self, *p2, *p3, *p4, num_segments);
}
    PathRect                    :: (self: *ImDrawList, rect_min: ImVec2, rect_max: ImVec2, rounding: float = 0.0, rounding_corners: ImDrawCornerFlags = .All) {
    _internal_PathRect :: (self: *ImDrawList, rect_min: *ImVec2, rect_max: *ImVec2, rounding: float, rounding_corners: ImDrawCornerFlags) #foreign imgui_lib "?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z";
    _internal_PathRect(self, *rect_min, *rect_max, rounding, rounding_corners);
}
    PopClipRect                 :: (self: *ImDrawList) #foreign imgui_lib "?PopClipRect@ImDrawList@@QEAAXXZ";
    PopTextureID                :: (self: *ImDrawList) #foreign imgui_lib "?PopTextureID@ImDrawList@@QEAAXXZ";
    PrimQuadUV                  :: (self: *ImDrawList, a: ImVec2, b: ImVec2, c: ImVec2, d: ImVec2, uv_a: ImVec2, uv_b: ImVec2, uv_c: ImVec2, uv_d: ImVec2, col: u32) {
    _internal_PrimQuadUV :: (self: *ImDrawList, a: *ImVec2, b: *ImVec2, c: *ImVec2, d: *ImVec2, uv_a: *ImVec2, uv_b: *ImVec2, uv_c: *ImVec2, uv_d: *ImVec2, col: u32) #foreign imgui_lib "?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z";
    _internal_PrimQuadUV(self, *a, *b, *c, *d, *uv_a, *uv_b, *uv_c, *uv_d, col);
}
    PrimRect                    :: (self: *ImDrawList, a: ImVec2, b: ImVec2, col: u32) {
    _internal_PrimRect :: (self: *ImDrawList, a: *ImVec2, b: *ImVec2, col: u32) #foreign imgui_lib "?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z";
    _internal_PrimRect(self, *a, *b, col);
}
    PrimRectUV                  :: (self: *ImDrawList, a: ImVec2, b: ImVec2, uv_a: ImVec2, uv_b: ImVec2, col: u32) {
    _internal_PrimRectUV :: (self: *ImDrawList, a: *ImVec2, b: *ImVec2, uv_a: *ImVec2, uv_b: *ImVec2, col: u32) #foreign imgui_lib "?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z";
    _internal_PrimRectUV(self, *a, *b, *uv_a, *uv_b, col);
}
    PrimReserve                 :: (self: *ImDrawList, idx_count: s32, vtx_count: s32) #foreign imgui_lib "?PrimReserve@ImDrawList@@QEAAXHH@Z";
    PrimUnreserve               :: (self: *ImDrawList, idx_count: s32, vtx_count: s32) #foreign imgui_lib "?PrimUnreserve@ImDrawList@@QEAAXHH@Z";
    PushClipRect                :: (self: *ImDrawList, clip_rect_min: ImVec2, clip_rect_max: ImVec2, intersect_with_current_clip_rect: bool = false) #foreign imgui_lib "?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z";
    PushClipRectFullScreen      :: (self: *ImDrawList) #foreign imgui_lib "?PushClipRectFullScreen@ImDrawList@@QEAAXXZ";
    PushTextureID               :: (self: *ImDrawList, texture_id: ImTextureID) #foreign imgui_lib "?PushTextureID@ImDrawList@@QEAAXPEAX@Z";
    _ClearFreeMemory            :: (self: *ImDrawList) #foreign imgui_lib "?_ClearFreeMemory@ImDrawList@@QEAAXXZ";
    _OnChangedClipRect          :: (self: *ImDrawList) #foreign imgui_lib "?_OnChangedClipRect@ImDrawList@@QEAAXXZ";
    _OnChangedTextureID         :: (self: *ImDrawList) #foreign imgui_lib "?_OnChangedTextureID@ImDrawList@@QEAAXXZ";
    _OnChangedVtxOffset         :: (self: *ImDrawList) #foreign imgui_lib "?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ";
    _PopUnusedDrawCmd           :: (self: *ImDrawList) #foreign imgui_lib "?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ";
    _ResetForNewFrame           :: (self: *ImDrawList) #foreign imgui_lib "?_ResetForNewFrame@ImDrawList@@QEAAXXZ";
}

ImDrawListSharedData :: struct {
    TexUvWhitePixel: ImVec2;
    Font: *ImFont;
    FontSize: float;
    CurveTessellationTol: float;
    CircleSegmentMaxError: float;
    ClipRectFullscreen: ImVec4;
    InitialFlags: ImDrawListFlags;
    ArcFastVtx: [12*1]ImVec2;
    CircleSegmentCounts: [64]u8;
    TexUvLines: *ImVec4;

    SetCircleSegmentMaxError     :: (self: *ImDrawListSharedData, max_error: float) #foreign imgui_lib "?SetCircleSegmentMaxError@ImDrawListSharedData@@QEAAXM@Z";
}

ImDrawListSplitter :: struct {
    _Current: s32;
    _Count: s32;
    _Channels: ImVector(ImDrawChannel);

    ClearFreeMemory       :: (self: *ImDrawListSplitter) #foreign imgui_lib "?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ";
    Merge                 :: (self: *ImDrawListSplitter, draw_list: *ImDrawList) #foreign imgui_lib "?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z";
    SetCurrentChannel     :: (self: *ImDrawListSplitter, draw_list: *ImDrawList, channel_idx: s32) #foreign imgui_lib "?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z";
    Split                 :: (self: *ImDrawListSplitter, draw_list: *ImDrawList, count: s32) #foreign imgui_lib "?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z";
}

ImDrawVert :: struct {
    pos: ImVec2;
    uv: ImVec2;
    col: u32;
}

ImFont :: struct {
    IndexAdvanceX: ImVector(float);
    FallbackAdvanceX: float;
    FontSize: float;
    IndexLookup: ImVector(ImWchar);
    Glyphs: ImVector(ImFontGlyph);
    FallbackGlyph: *ImFontGlyph;
    ContainerAtlas: *ImFontAtlas;
    ConfigData: *ImFontConfig;
    ConfigDataCount: s16;
    FallbackChar: ImWchar;
    EllipsisChar: ImWchar;
    DirtyLookupTables: bool;
    Scale: float;
    Ascent: float;
    Descent: float;
    MetricsTotalSurface: s32;
    Used4kPagesMap: [(0xFFFF+1)/4096/8]u8;

    AddGlyph                  :: (self: *ImFont, src_cfg: *ImFontConfig, c: ImWchar, x0: float, y0: float, x1: float, y1: float, u0: float, v0: float, u1: float, v1: float, advance_x: float) #foreign imgui_lib "?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z";
    AddRemapChar              :: (self: *ImFont, dst: ImWchar, src: ImWchar, overwrite_dst: bool = true) #foreign imgui_lib "?AddRemapChar@ImFont@@QEAAXGG_N@Z";
    BuildLookupTable          :: (self: *ImFont) #foreign imgui_lib "?BuildLookupTable@ImFont@@QEAAXXZ";
    CalcWordWrapPositionA     :: (self: *ImFont, scale: float, text: string, wrap_width: float) -> *u8 {
    _internal_CalcWordWrapPositionA :: (self: *ImFont, scale: float, text: *u8, text_end: *u8, wrap_width: float) -> *u8 #foreign imgui_lib "?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z";
    return _internal_CalcWordWrapPositionA(self, scale, text.data, text.data + text.count, wrap_width);
}
    ClearOutputData           :: (self: *ImFont) #foreign imgui_lib "?ClearOutputData@ImFont@@QEAAXXZ";
    FindGlyph                 :: (self: *ImFont, c: ImWchar) -> *ImFontGlyph #foreign imgui_lib "?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z";
    FindGlyphNoFallback       :: (self: *ImFont, c: ImWchar) -> *ImFontGlyph #foreign imgui_lib "?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z";
    GrowIndex                 :: (self: *ImFont, new_size: s32) #foreign imgui_lib "?GrowIndex@ImFont@@QEAAXH@Z";
    IsGlyphRangeUnused        :: (self: *ImFont, c_begin: u32, c_last: u32) -> bool #foreign imgui_lib "?IsGlyphRangeUnused@ImFont@@QEAA_NII@Z";
    RenderChar                :: (self: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: u32, c: ImWchar) #foreign imgui_lib "?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z";
    RenderText                :: (self: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: u32, clip_rect: ImVec4, text: string, wrap_width: float = 0.0, cpu_fine_clip: bool = false) {
    _internal_RenderText :: (self: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: u32, clip_rect: *ImVec4, text_begin: *u8, text_end: *u8, wrap_width: float, cpu_fine_clip: bool) #foreign imgui_lib "?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z";
    _internal_RenderText(self, draw_list, size, pos, col, *clip_rect, text.data, text.data + text.count, wrap_width, cpu_fine_clip);
}
    SetFallbackChar           :: (self: *ImFont, c: ImWchar) #foreign imgui_lib "?SetFallbackChar@ImFont@@QEAAXG@Z";
    SetGlyphVisible           :: (self: *ImFont, c: ImWchar, visible: bool) #foreign imgui_lib "?SetGlyphVisible@ImFont@@QEAAXG_N@Z";
}

ImFontAtlas :: struct {
    Locked: bool;
    Flags: ImFontAtlasFlags;
    TexID: ImTextureID;
    TexDesiredWidth: s32;
    TexGlyphPadding: s32;
    TexPixelsAlpha8: *u8;
    TexPixelsRGBA32: *u32;
    TexWidth: s32;
    TexHeight: s32;
    TexUvScale: ImVec2;
    TexUvWhitePixel: ImVec2;
    Fonts: ImVector(*ImFont);
    CustomRects: ImVector(ImFontAtlasCustomRect);
    ConfigData: ImVector(ImFontConfig);
    TexUvLines: [(63)+1]ImVec4;
    PackIdMouseCursors: s32;
    PackIdLines: s32;

    AddCustomRectFontGlyph                    :: (self: *ImFontAtlas, font: *ImFont, id: ImWchar, width: s32, height: s32, advance_x: float, offset: ImVec2 = ImVec2.{0,0}) -> s32 {
    _internal_AddCustomRectFontGlyph :: (self: *ImFontAtlas, font: *ImFont, id: ImWchar, width: s32, height: s32, advance_x: float, offset: *ImVec2) -> s32 #foreign imgui_lib "?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z";
    return _internal_AddCustomRectFontGlyph(self, font, id, width, height, advance_x, *offset);
}
    AddCustomRectRegular                      :: (self: *ImFontAtlas, width: s32, height: s32) -> s32 #foreign imgui_lib "?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z";
    AddFont                                   :: (self: *ImFontAtlas, font_cfg: *ImFontConfig) -> *ImFont #foreign imgui_lib "?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z";
    AddFontDefault                            :: (self: *ImFontAtlas, font_cfg: *ImFontConfig = null) -> *ImFont #foreign imgui_lib "?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z";
    AddFontFromFileTTF                        :: (self: *ImFontAtlas, filename: *u8, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #foreign imgui_lib "?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryCompressedBase85TTF      :: (self: *ImFontAtlas, compressed_font_data_base85: *u8, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #foreign imgui_lib "?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryCompressedTTF            :: (self: *ImFontAtlas, compressed_font_data: *void, compressed_font_size: s32, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #foreign imgui_lib "?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryTTF                      :: (self: *ImFontAtlas, font_data: *void, font_size: s32, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #foreign imgui_lib "?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z";
    Build                                     :: (self: *ImFontAtlas) -> bool #foreign imgui_lib "?Build@ImFontAtlas@@QEAA_NXZ";
    CalcCustomRectUV                          :: (self: *ImFontAtlas, rect: *ImFontAtlasCustomRect, out_uv_min: *ImVec2, out_uv_max: *ImVec2) #foreign imgui_lib "?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z";
    Clear                                     :: (self: *ImFontAtlas) #foreign imgui_lib "?Clear@ImFontAtlas@@QEAAXXZ";
    ClearFonts                                :: (self: *ImFontAtlas) #foreign imgui_lib "?ClearFonts@ImFontAtlas@@QEAAXXZ";
    ClearInputData                            :: (self: *ImFontAtlas) #foreign imgui_lib "?ClearInputData@ImFontAtlas@@QEAAXXZ";
    ClearTexData                              :: (self: *ImFontAtlas) #foreign imgui_lib "?ClearTexData@ImFontAtlas@@QEAAXXZ";
    GetGlyphRangesChineseFull                 :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesChineseSimplifiedCommon     :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesCyrillic                    :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesDefault                     :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesJapanese                    :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesKorean                      :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesThai                        :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesVietnamese                  :: (self: *ImFontAtlas) -> *ImWchar #foreign imgui_lib "?GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ";
    GetMouseCursorTexData                     :: (self: *ImFontAtlas, cursor: MouseCursor, out_offset: *ImVec2, out_size: *ImVec2, out_uv_border: [2]ImVec2, out_uv_fill: [2]ImVec2) -> bool #foreign imgui_lib "?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z";
    GetTexDataAsAlpha8                        :: (self: *ImFontAtlas, out_pixels: **u8, out_width: *s32, out_height: *s32, out_bytes_per_pixel: *s32 = null) #foreign imgui_lib "?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z";
    GetTexDataAsRGBA32                        :: (self: *ImFontAtlas, out_pixels: **u8, out_width: *s32, out_height: *s32, out_bytes_per_pixel: *s32 = null) #foreign imgui_lib "?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z";
}

ImFontAtlasCustomRect :: struct {
    Width: u16;
    Height: u16;
    X: u16;
    Y: u16;
    GlyphID: u32;
    GlyphAdvanceX: float;
    GlyphOffset: ImVec2;
    Font: *ImFont;
}

ImFontConfig :: struct {
    FontData: *void;
    FontDataSize: s32;
    FontDataOwnedByAtlas: bool;
    FontNo: s32;
    SizePixels: float;
    OversampleH: s32;
    OversampleV: s32;
    PixelSnapH: bool;
    GlyphExtraSpacing: ImVec2;
    GlyphOffset: ImVec2;
    GlyphRanges: *ImWchar;
    GlyphMinAdvanceX: float;
    GlyphMaxAdvanceX: float;
    MergeMode: bool;
    RasterizerFlags: u32;
    RasterizerMultiply: float;
    EllipsisChar: ImWchar;
    Name: [40]s8;
    DstFont: *ImFont;
}

ImFontGlyph :: struct {
    Codepoint: u32;
    #place Codepoint; Visible: u32;
    AdvanceX: float;
    X0: float;
    Y0: float;
    X1: float;
    Y1: float;
    U0: float;
    V0: float;
    U1: float;
    V1: float;
}

ImFontGlyphRangesBuilder :: struct {
    UsedChars: ImVector(u32);

    AddRanges     :: (self: *ImFontGlyphRangesBuilder, ranges: *ImWchar) #foreign imgui_lib "?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z";
    AddText       :: (self: *ImFontGlyphRangesBuilder, text: string) {
    _internal_AddText :: (self: *ImFontGlyphRangesBuilder, text: *u8, text_end: *u8) #foreign imgui_lib "?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z";
    _internal_AddText(self, text.data, text.data + text.count);
}
}

ColorMod :: struct {
    Col_: Col;
    BackupValue: ImVec4;
}

Context :: struct #type_info_none {
    Initialized: bool;
    FontAtlasOwnedByContext: bool;
    IO_: IO;
    PlatformIO_: PlatformIO;
    Style_: Style;
    ConfigFlagsCurrFrame: ConfigFlags;
    ConfigFlagsLastFrame: ConfigFlags;
    Font: *ImFont;
    FontSize: float;
    FontBaseSize: float;
    DrawListSharedData: ImDrawListSharedData;
    Time: float64;
    FrameCount: s32;
    FrameCountEnded: s32;
    FrameCountPlatformEnded: s32;
    FrameCountRendered: s32;
    WithinFrameScope: bool;
    WithinFrameScopeWithImplicitWindow: bool;
    WithinEndChild: bool;
    GcCompactAll: bool;
    TestEngineHookItems: bool;
    TestEngineHookIdInfo: ID;
    TestEngine: *void;
    Windows: ImVector(*Window);
    WindowsFocusOrder: ImVector(*Window);
    WindowsTempSortBuffer: ImVector(*Window);
    CurrentWindowStack: ImVector(*Window);
    WindowsById: Storage;
    WindowsActiveCount: s32;
    CurrentWindow: *Window;
    HoveredWindow: *Window;
    HoveredRootWindow: *Window;
    HoveredWindowUnderMovingWindow: *Window;
    HoveredDockNode: *DockNode;
    MovingWindow: *Window;
    WheelingWindow: *Window;
    WheelingWindowRefMousePos: ImVec2;
    WheelingWindowTimer: float;
    HoveredId: ID;
    HoveredIdPreviousFrame: ID;
    HoveredIdAllowOverlap: bool;
    HoveredIdDisabled: bool;
    HoveredIdTimer: float;
    HoveredIdNotActiveTimer: float;
    ActiveId: ID;
    ActiveIdIsAlive: ID;
    ActiveIdTimer: float;
    ActiveIdIsJustActivated: bool;
    ActiveIdAllowOverlap: bool;
    ActiveIdNoClearOnFocusLoss: bool;
    ActiveIdHasBeenPressedBefore: bool;
    ActiveIdHasBeenEditedBefore: bool;
    ActiveIdHasBeenEditedThisFrame: bool;
    ActiveIdUsingNavDirMask: u32;
    ActiveIdUsingNavInputMask: u32;
    ActiveIdUsingKeyInputMask: u64;
    ActiveIdClickOffset: ImVec2;
    ActiveIdWindow: *Window;
    ActiveIdSource: InputSource;
    ActiveIdMouseButton: s32;
    ActiveIdPreviousFrame: ID;
    ActiveIdPreviousFrameIsAlive: bool;
    ActiveIdPreviousFrameHasBeenEditedBefore: bool;
    ActiveIdPreviousFrameWindow: *Window;
    LastActiveId: ID;
    LastActiveIdTimer: float;
    NextWindowData_: NextWindowData;
    NextItemData_: NextItemData;
    ColorStack: ImVector(ColorMod);
    StyleVarStack: ImVector(StyleMod);
    FontStack: ImVector(*ImFont);
    FocusScopeStack: ImVector(ID);
    ItemFlagsStack: ImVector(ItemFlags);
    GroupStack: ImVector(GroupData);
    OpenPopupStack: ImVector(PopupData);
    BeginPopupStack: ImVector(PopupData);
    Viewports: ImVector(*ViewportP);
    CurrentDpiScale: float;
    CurrentViewport: *ViewportP;
    MouseViewport: *ViewportP;
    MouseLastHoveredViewport: *ViewportP;
    ViewportFrontMostStampCount: s32;
    NavWindow: *Window;
    NavId: ID;
    NavFocusScopeId: ID;
    NavActivateId: ID;
    NavActivateDownId: ID;
    NavActivatePressedId: ID;
    NavInputId: ID;
    NavJustTabbedId: ID;
    NavJustMovedToId: ID;
    NavJustMovedToFocusScopeId: ID;
    NavJustMovedToKeyMods: KeyModFlags;
    NavNextActivateId: ID;
    NavInputSource: InputSource;
    NavScoringRect: ImRect;
    NavScoringCount: s32;
    NavLayer_: NavLayer;
    NavIdTabCounter: s32;
    NavIdIsAlive: bool;
    NavMousePosDirty: bool;
    NavDisableHighlight: bool;
    NavDisableMouseHover: bool;
    NavAnyRequest: bool;
    NavInitRequest: bool;
    NavInitRequestFromMove: bool;
    NavInitResultId: ID;
    NavInitResultRectRel: ImRect;
    NavMoveRequest: bool;
    NavMoveRequestFlags: NavMoveFlags;
    NavMoveRequestForward: NavForward;
    NavMoveRequestKeyMods: KeyModFlags;
    NavMoveDir: Dir;
    NavMoveDirLast: Dir;
    NavMoveClipDir: Dir;
    NavMoveResultLocal: NavMoveResult;
    NavMoveResultLocalVisibleSet: NavMoveResult;
    NavMoveResultOther: NavMoveResult;
    NavWrapRequestWindow: *Window;
    NavWrapRequestFlags: NavMoveFlags;
    NavWindowingTarget: *Window;
    NavWindowingTargetAnim: *Window;
    NavWindowingListWindow: *Window;
    NavWindowingTimer: float;
    NavWindowingHighlightAlpha: float;
    NavWindowingToggleLayer: bool;
    FocusRequestCurrWindow: *Window;
    FocusRequestNextWindow: *Window;
    FocusRequestCurrCounterRegular: s32;
    FocusRequestCurrCounterTabStop: s32;
    FocusRequestNextCounterRegular: s32;
    FocusRequestNextCounterTabStop: s32;
    FocusTabPressed: bool;
    DimBgRatio: float;
    MouseCursor_: MouseCursor;
    DragDropActive: bool;
    DragDropWithinSource: bool;
    DragDropWithinTarget: bool;
    DragDropSourceFlags: DragDropFlags;
    DragDropSourceFrameCount: s32;
    DragDropMouseButton: s32;
    DragDropPayload: Payload;
    DragDropTargetRect: ImRect;
    DragDropTargetId: ID;
    DragDropAcceptFlags: DragDropFlags;
    DragDropAcceptIdCurrRectSurface: float;
    DragDropAcceptIdCurr: ID;
    DragDropAcceptIdPrev: ID;
    DragDropAcceptFrameCount: s32;
    DragDropHoldJustPressedId: ID;
    DragDropPayloadBufHeap: ImVector(u8);
    DragDropPayloadBufLocal: [16]u8;
    CurrentTable: *Table;
    Tables: ImPool(Table);
    CurrentTableStack: ImVector(PtrOrIndex);
    TablesLastTimeActive: ImVector(float);
    DrawChannelsTempMergeBuffer: ImVector(ImDrawChannel);
    CurrentTabBar: *TabBar;
    TabBars: ImPool(TabBar);
    CurrentTabBarStack: ImVector(PtrOrIndex);
    ShrinkWidthBuffer: ImVector(ShrinkWidthItem);
    LastValidMousePos: ImVec2;
    InputTextState_: InputTextState;
    InputTextPasswordFont: ImFont;
    TempInputId: ID;
    ColorEditOptions: ColorEditFlags;
    ColorEditLastHue: float;
    ColorEditLastSat: float;
    ColorEditLastColor: [3]float;
    ColorPickerRef: ImVec4;
    SliderCurrentAccum: float;
    SliderCurrentAccumDirty: bool;
    DragCurrentAccumDirty: bool;
    DragCurrentAccum: float;
    DragSpeedDefaultRatio: float;
    ScrollbarClickDeltaToGrabCenter: float;
    TooltipOverrideCount: s32;
    TooltipSlowDelay: float;
    ClipboardHandlerData: ImVector(s8);
    MenusIdSubmittedThisFrame: ImVector(ID);
    PlatformImePos: ImVec2;
    PlatformImeLastPos: ImVec2;
    PlatformImePosViewport: *ViewportP;
    PlatformLocaleDecimalPoint: s8;
    DockContext_: DockContext;
    SettingsLoaded: bool;
    SettingsDirtyTimer: float;
    SettingsIniData: TextBuffer;
    SettingsHandlers: ImVector(SettingsHandler);
    SettingsWindows: ImChunkStream(WindowSettings);
    SettingsTables: ImChunkStream(TableSettings);
    Hooks: ImVector(ContextHook);
    LogEnabled: bool;
    LogType_: LogType;
    LogFile: ImFileHandle;
    LogBuffer: TextBuffer;
    LogLinePosY: float;
    LogLineFirstItem: bool;
    LogDepthRef: s32;
    LogDepthToExpand: s32;
    LogDepthToExpandDefault: s32;
    DebugItemPickerActive: bool;
    DebugItemPickerBreakId: ID;
    DebugMetricsConfig: MetricsConfig;
    FramerateSecPerFrame: [120]float;
    FramerateSecPerFrameIdx: s32;
    FramerateSecPerFrameAccum: float;
    WantCaptureMouseNextFrame: s32;
    WantCaptureKeyboardNextFrame: s32;
    WantTextInputNextFrame: s32;
    TempBuffer: [1024*3+1]s8;
}

ContextHook :: struct {
    Type: ContextHookType;
    Owner: ID;
    Callback: ContextHookCallback;
    UserData: *void;
}

DataTypeInfo :: struct {
    Size: u64;
    Name: *u8;
    PrintFmt: *u8;
    ScanFmt: *u8;
}

DataTypeTempStorage :: struct {
    Data: [8]u8;
}

DockContext :: struct {
    Nodes: Storage;
    Requests: ImVector(DockRequest);
    NodesSettings: ImVector(DockNodeSettings);
    WantFullRebuild: bool;
}

DockNode :: struct {
    ID_: ID;
    SharedFlags: DockNodeFlags;
    LocalFlags: DockNodeFlags;
    State: DockNodeState;
    ParentNode: *DockNode;
    ChildNodes: [2]*DockNode;
    Windows: ImVector(*Window);
    TabBar_: *TabBar;
    Pos: ImVec2;
    Size: ImVec2;
    SizeRef: ImVec2;
    SplitAxis: Axis;
    WindowClass_: WindowClass;
    HostWindow: *Window;
    VisibleWindow: *Window;
    CentralNode: *DockNode;
    OnlyNodeWithWindows: *DockNode;
    LastFrameAlive: s32;
    LastFrameActive: s32;
    LastFrameFocused: s32;
    LastFocusedNodeId: ID;
    SelectedTabId: ID;
    WantCloseTabId: ID;
    AuthorityForPos: DataAuthority;
    AuthorityForSize: DataAuthority;
    AuthorityForViewport: DataAuthority;
    IsVisible: bool;
    IsFocused: bool;
    HasCloseButton: bool;
    HasWindowMenuButton: bool;
    EnableCloseButton: bool;
    WantCloseAll: bool;
    WantLockSizeOnce: bool;
    WantMouseMove: bool;
    WantHiddenTabBarUpdate: bool;
    WantHiddenTabBarToggle: bool;
    MarkedForPosSizeWrite: bool;
}

GroupData :: struct {
    WindowID: ID;
    BackupCursorPos: ImVec2;
    BackupCursorMaxPos: ImVec2;
    BackupIndent: ImVec1;
    BackupGroupOffset: ImVec1;
    BackupCurrLineSize: ImVec2;
    BackupCurrLineTextBaseOffset: float;
    BackupActiveIdIsAlive: ID;
    BackupActiveIdPreviousFrameIsAlive: bool;
    EmitItem: bool;
}

IO :: struct {
    ConfigFlags_: ConfigFlags;
    BackendFlags_: BackendFlags;
    DisplaySize: ImVec2;
    DeltaTime: float;
    IniSavingRate: float;
    IniFilename: *u8;
    LogFilename: *u8;
    MouseDoubleClickTime: float;
    MouseDoubleClickMaxDist: float;
    MouseDragThreshold: float;
    KeyMap: [Key.COUNT]s32;
    KeyRepeatDelay: float;
    KeyRepeatRate: float;
    UserData: *void;
    Fonts: *ImFontAtlas;
    FontGlobalScale: float;
    FontAllowUserScaling: bool;
    FontDefault: *ImFont;
    DisplayFramebufferScale: ImVec2;
    ConfigDockingNoSplit: bool;
    ConfigDockingWithShift: bool;
    ConfigDockingAlwaysTabBar: bool;
    ConfigDockingTransparentPayload: bool;
    ConfigViewportsNoAutoMerge: bool;
    ConfigViewportsNoTaskBarIcon: bool;
    ConfigViewportsNoDecoration: bool;
    ConfigViewportsNoDefaultParent: bool;
    MouseDrawCursor: bool;
    ConfigMacOSXBehaviors: bool;
    ConfigInputTextCursorBlink: bool;
    ConfigWindowsResizeFromEdges: bool;
    ConfigWindowsMoveFromTitleBarOnly: bool;
    ConfigMemoryCompactTimer: float;
    BackendPlatformName: *u8;
    BackendRendererName: *u8;
    BackendPlatformUserData: *void;
    BackendRendererUserData: *void;
    BackendLanguageUserData: *void;
    GetClipboardTextFn: (user_data: *void) -> *u8 #c_call;
    SetClipboardTextFn: (user_data: *void, text: *u8) #c_call;
    ClipboardUserData: *void;
    MousePos: ImVec2;
    MouseDown: [5]bool;
    MouseWheel: float;
    MouseWheelH: float;
    MouseHoveredViewport: ID;
    KeyCtrl: bool;
    KeyShift: bool;
    KeyAlt: bool;
    KeySuper: bool;
    KeysDown: [512]bool;
    NavInputs: [NavInput.COUNT]float;
    WantCaptureMouse: bool;
    WantCaptureKeyboard: bool;
    WantTextInput: bool;
    WantSetMousePos: bool;
    WantSaveIniSettings: bool;
    NavActive: bool;
    NavVisible: bool;
    Framerate: float;
    MetricsRenderVertices: s32;
    MetricsRenderIndices: s32;
    MetricsRenderWindows: s32;
    MetricsActiveWindows: s32;
    MetricsActiveAllocations: s32;
    MouseDelta: ImVec2;
    KeyMods: KeyModFlags;
    MousePosPrev: ImVec2;
    MouseClickedPos: [5]ImVec2;
    MouseClickedTime: [5]float64;
    MouseClicked: [5]bool;
    MouseDoubleClicked: [5]bool;
    MouseReleased: [5]bool;
    MouseDownOwned: [5]bool;
    MouseDownWasDoubleClick: [5]bool;
    MouseDownDuration: [5]float;
    MouseDownDurationPrev: [5]float;
    MouseDragMaxDistanceAbs: [5]ImVec2;
    MouseDragMaxDistanceSqr: [5]float;
    KeysDownDuration: [512]float;
    KeysDownDurationPrev: [512]float;
    NavInputsDownDuration: [NavInput.COUNT]float;
    NavInputsDownDurationPrev: [NavInput.COUNT]float;
    PenPressure: float;
    InputQueueSurrogate: ImWchar16;
    InputQueueCharacters: ImVector(ImWchar);

    AddInputCharacter          :: (self: *IO, c: u32) #foreign imgui_lib "?AddInputCharacter@ImGuiIO@@QEAAXI@Z";
    AddInputCharacterUTF16     :: (self: *IO, c: ImWchar16) #foreign imgui_lib "?AddInputCharacterUTF16@ImGuiIO@@QEAAXG@Z";
    AddInputCharactersUTF8     :: (self: *IO, str: *u8) #foreign imgui_lib "?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z";
    ClearInputCharacters       :: (self: *IO) #foreign imgui_lib "?ClearInputCharacters@ImGuiIO@@QEAAXXZ";
}

InputTextCallbackData :: struct {
    EventFlag: InputTextFlags;
    Flags: InputTextFlags;
    UserData: *void;
    EventChar: ImWchar;
    EventKey: Key;
    Buf: *u8;
    BufTextLen: s32;
    BufSize: s32;
    BufDirty: bool;
    CursorPos: s32;
    SelectionStart: s32;
    SelectionEnd: s32;

    DeleteChars     :: (self: *InputTextCallbackData, pos: s32, bytes_count: s32) #foreign imgui_lib "?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z";
    InsertChars     :: (self: *InputTextCallbackData, pos: s32, text: string) {
    _internal_InsertChars :: (self: *InputTextCallbackData, pos: s32, text: *u8, text_end: *u8) #foreign imgui_lib "?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z";
    _internal_InsertChars(self, pos, text.data, text.data + text.count);
}
}

InputTextState :: struct {
    ID_: ID;
    CurLenW: s32;
    CurLenA: s32;
    TextW: ImVector(ImWchar);
    TextA: ImVector(s8);
    InitialTextA: ImVector(s8);
    TextAIsValid: bool;
    BufCapacityA: s32;
    ScrollX: float;
    Stb: STB_TexteditState;
    CursorAnim: float;
    CursorFollow: bool;
    SelectedAllMouseLock: bool;
    Edited: bool;
    UserFlags: InputTextFlags;
    UserCallback: InputTextCallback;
    UserCallbackData: *void;

    ClearFreeMemory       :: (self: *InputTextState) #foreign imgui_lib "?ClearFreeMemory@ImGuiInputTextState@@QEAAXXZ";
    ClearSelection        :: (self: *InputTextState) #foreign imgui_lib "?ClearSelection@ImGuiInputTextState@@QEAAXXZ";
    ClearText             :: (self: *InputTextState) #foreign imgui_lib "?ClearText@ImGuiInputTextState@@QEAAXXZ";
    CursorAnimReset       :: (self: *InputTextState) #foreign imgui_lib "?CursorAnimReset@ImGuiInputTextState@@QEAAXXZ";
    CursorClamp           :: (self: *InputTextState) #foreign imgui_lib "?CursorClamp@ImGuiInputTextState@@QEAAXXZ";
    GetRedoAvailCount     :: (self: *InputTextState) -> s32 #foreign imgui_lib "?GetRedoAvailCount@ImGuiInputTextState@@QEBAHXZ";
    GetUndoAvailCount     :: (self: *InputTextState) -> s32 #foreign imgui_lib "?GetUndoAvailCount@ImGuiInputTextState@@QEBAHXZ";
    HasSelection          :: (self: *InputTextState) -> bool #foreign imgui_lib "?HasSelection@ImGuiInputTextState@@QEBA_NXZ";
    OnKeyPressed          :: (self: *InputTextState, key: s32) #foreign imgui_lib "?OnKeyPressed@ImGuiInputTextState@@QEAAXH@Z";
    SelectAll             :: (self: *InputTextState) #foreign imgui_lib "?SelectAll@ImGuiInputTextState@@QEAAXXZ";
}

LastItemDataBackup :: struct {
    LastItemId: ID;
    LastItemStatusFlags: ItemStatusFlags;
    LastItemRect: ImRect;
    LastItemDisplayRect: ImRect;
}

ListClipper :: struct {
    DisplayStart: s32;
    DisplayEnd: s32;
    ItemsCount: s32;
    StepNo: s32;
    ItemsFrozen: s32;
    ItemsHeight: float;
    StartPosY: float;

    Begin     :: (self: *ListClipper, items_count: s32, items_height: float = 1.0) #foreign imgui_lib "?Begin@ImGuiListClipper@@QEAAXHM@Z";
    End       :: (self: *ListClipper) #foreign imgui_lib "?End@ImGuiListClipper@@QEAAXXZ";
    Step      :: (self: *ListClipper) -> bool #foreign imgui_lib "?Step@ImGuiListClipper@@QEAA_NXZ";
}

MenuColumns :: struct {
    Spacing: float;
    Width: float;
    NextWidth: float;
    Pos: [3]float;
    NextWidths: [3]float;

    CalcExtraSpace     :: (self: *MenuColumns, avail_w: float) -> float #foreign imgui_lib "?CalcExtraSpace@ImGuiMenuColumns@@QEBAMM@Z";
    DeclColumns        :: (self: *MenuColumns, w0: float, w1: float, w2: float) -> float #foreign imgui_lib "?DeclColumns@ImGuiMenuColumns@@QEAAMMMM@Z";
    Update             :: (self: *MenuColumns, count: s32, spacing: float, clear: bool) #foreign imgui_lib "?Update@ImGuiMenuColumns@@QEAAXHM_N@Z";
}

MetricsConfig :: struct {
    ShowWindowsRects: bool;
    ShowWindowsBeginOrder: bool;
    ShowTablesRects: bool;
    ShowDrawCmdMesh: bool;
    ShowDrawCmdBoundingBoxes: bool;
    ShowDockingNodes: bool;
    ShowWindowsRectsType: s32;
    ShowTablesRectsType: s32;
}

NavMoveResult :: struct {
    Window_: *Window;
    ID_: ID;
    FocusScopeId: ID;
    DistBox: float;
    DistCenter: float;
    DistAxial: float;
    RectRel: ImRect;
}

NextItemData :: struct {
    Flags: NextItemDataFlags;
    Width: float;
    FocusScopeId: ID;
    OpenCond: Cond;
    OpenVal: bool;
}

NextWindowData :: struct {
    Flags: NextWindowDataFlags;
    PosCond: Cond;
    SizeCond: Cond;
    CollapsedCond: Cond;
    DockCond: Cond;
    PosVal: ImVec2;
    PosPivotVal: ImVec2;
    SizeVal: ImVec2;
    ContentSizeVal: ImVec2;
    ScrollVal: ImVec2;
    PosUndock: bool;
    CollapsedVal: bool;
    SizeConstraintRect: ImRect;
    SizeCallback_: SizeCallback;
    SizeCallbackUserData: *void;
    BgAlphaVal: float;
    ViewportId: ID;
    DockId: ID;
    WindowClass_: WindowClass;
    MenuBarOffsetMinVal: ImVec2;
}

OldColumnData :: struct {
    OffsetNorm: float;
    OffsetNormBeforeResize: float;
    Flags: OldColumnFlags;
    ClipRect: ImRect;
}

OldColumns :: struct {
    ID_: ID;
    Flags: OldColumnFlags;
    IsFirstFrame: bool;
    IsBeingResized: bool;
    Current: s32;
    Count: s32;
    OffMinX: float;
    OffMaxX: float;
    LineMinY: float;
    LineMaxY: float;
    HostCursorPosY: float;
    HostCursorMaxPosX: float;
    HostInitialClipRect: ImRect;
    HostBackupClipRect: ImRect;
    HostBackupParentWorkRect: ImRect;
    Columns: ImVector(OldColumnData);
    Splitter: ImDrawListSplitter;
}

OnceUponAFrame :: struct {
    RefFrame: s32;
}

Payload :: struct {
    Data: *void;
    DataSize: s32;
    SourceId: ID;
    SourceParentId: ID;
    DataFrameCount: s32;
    DataType: [32+1]s8;
    Preview: bool;
    Delivery: bool;
}

PlatformIO :: struct {
    Platform_CreateWindow: (vp: *Viewport) #c_call;
    Platform_DestroyWindow: (vp: *Viewport) #c_call;
    Platform_ShowWindow: (vp: *Viewport) #c_call;
    Platform_SetWindowPos: (vp: *Viewport, pos: ImVec2) #c_call;
    Platform_GetWindowPos: (vp: *Viewport) -> ImVec2 #c_call;
    Platform_SetWindowSize: (vp: *Viewport, size: ImVec2) #c_call;
    Platform_GetWindowSize: (vp: *Viewport) -> ImVec2 #c_call;
    Platform_SetWindowFocus: (vp: *Viewport) #c_call;
    Platform_GetWindowFocus: (vp: *Viewport) -> bool #c_call;
    Platform_GetWindowMinimized: (vp: *Viewport) -> bool #c_call;
    Platform_SetWindowTitle: (vp: *Viewport, str: *u8) #c_call;
    Platform_SetWindowAlpha: (vp: *Viewport, alpha: float) #c_call;
    Platform_UpdateWindow: (vp: *Viewport) #c_call;
    Platform_RenderWindow: (vp: *Viewport, render_arg: *void) #c_call;
    Platform_SwapBuffers: (vp: *Viewport, render_arg: *void) #c_call;
    Platform_GetWindowDpiScale: (vp: *Viewport) -> float #c_call;
    Platform_OnChangedViewport: (vp: *Viewport) #c_call;
    Platform_SetImeInputPos: (vp: *Viewport, pos: ImVec2) #c_call;
    Platform_CreateVkSurface: (vp: *Viewport, vk_inst: u64, vk_allocators: *void, out_vk_surface: *u64) -> s32 #c_call;
    Renderer_CreateWindow: (vp: *Viewport) #c_call;
    Renderer_DestroyWindow: (vp: *Viewport) #c_call;
    Renderer_SetWindowSize: (vp: *Viewport, size: ImVec2) #c_call;
    Renderer_RenderWindow: (vp: *Viewport, render_arg: *void) #c_call;
    Renderer_SwapBuffers: (vp: *Viewport, render_arg: *void) #c_call;
    Monitors: ImVector(PlatformMonitor);
    MainViewport: *Viewport;
    Viewports: ImVector(*Viewport);
}

PlatformMonitor :: struct {
    MainPos: ImVec2;
    MainSize: ImVec2;
    WorkPos: ImVec2;
    WorkSize: ImVec2;
    DpiScale: float;
}

PopupData :: struct {
    PopupId: ID;
    Window_: *Window;
    SourceWindow: *Window;
    OpenFrameCount: s32;
    OpenParentId: ID;
    OpenPopupPos: ImVec2;
    OpenMousePos: ImVec2;
}

PtrOrIndex :: struct {
    Ptr: *void;
    Index: s32;
}

SettingsHandler :: struct {
    TypeName: *u8;
    TypeHash: ID;
    ClearAllFn: (ctx: *Context, handler: *SettingsHandler) #c_call;
    ReadInitFn: (ctx: *Context, handler: *SettingsHandler) #c_call;
    ReadOpenFn: (ctx: *Context, handler: *SettingsHandler, name: *u8) -> *void #c_call;
    ReadLineFn: (ctx: *Context, handler: *SettingsHandler, entry: *void, line: *u8) #c_call;
    ApplyAllFn: (ctx: *Context, handler: *SettingsHandler) #c_call;
    WriteAllFn: (ctx: *Context, handler: *SettingsHandler, out_buf: *TextBuffer) #c_call;
    UserData: *void;
}

ShrinkWidthItem :: struct {
    Index: s32;
    Width: float;
}

SizeCallbackData :: struct {
    UserData: *void;
    Pos: ImVec2;
    CurrentSize: ImVec2;
    DesiredSize: ImVec2;
}

StackSizes :: struct {
    SizeOfIDStack: s16;
    SizeOfColorStack: s16;
    SizeOfStyleVarStack: s16;
    SizeOfFontStack: s16;
    SizeOfFocusScopeStack: s16;
    SizeOfGroupStack: s16;
    SizeOfBeginPopupStack: s16;

    CompareWithCurrentState     :: (self: *StackSizes) #foreign imgui_lib "?CompareWithCurrentState@ImGuiStackSizes@@QEAAXXZ";
    SetToCurrentState           :: (self: *StackSizes) #foreign imgui_lib "?SetToCurrentState@ImGuiStackSizes@@QEAAXXZ";
}

Storage :: struct {
    Data: ImVector(StoragePair);

    BuildSortByKey     :: (self: *Storage) #foreign imgui_lib "?BuildSortByKey@ImGuiStorage@@QEAAXXZ";
    GetBool            :: (self: *Storage, key: ID, default_val: bool = false) -> bool #foreign imgui_lib "?GetBool@ImGuiStorage@@QEBA_NI_N@Z";
    GetBoolRef         :: (self: *Storage, key: ID, default_val: bool = false) -> *bool #foreign imgui_lib "?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z";
    GetFloat           :: (self: *Storage, key: ID, default_val: float = 0.0) -> float #foreign imgui_lib "?GetFloat@ImGuiStorage@@QEBAMIM@Z";
    GetFloatRef        :: (self: *Storage, key: ID, default_val: float = 0.0) -> *float #foreign imgui_lib "?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z";
    GetInt             :: (self: *Storage, key: ID, default_val: s32 = 0) -> s32 #foreign imgui_lib "?GetInt@ImGuiStorage@@QEBAHIH@Z";
    GetIntRef          :: (self: *Storage, key: ID, default_val: s32 = 0) -> *s32 #foreign imgui_lib "?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z";
    GetVoidPtr         :: (self: *Storage, key: ID) -> *void #foreign imgui_lib "?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z";
    GetVoidPtrRef      :: (self: *Storage, key: ID, default_val: *void = null) -> **void #foreign imgui_lib "?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z";
    SetAllInt          :: (self: *Storage, val: s32) #foreign imgui_lib "?SetAllInt@ImGuiStorage@@QEAAXH@Z";
    SetBool            :: (self: *Storage, key: ID, val: bool) #foreign imgui_lib "?SetBool@ImGuiStorage@@QEAAXI_N@Z";
    SetFloat           :: (self: *Storage, key: ID, val: float) #foreign imgui_lib "?SetFloat@ImGuiStorage@@QEAAXIM@Z";
    SetInt             :: (self: *Storage, key: ID, val: s32) #foreign imgui_lib "?SetInt@ImGuiStorage@@QEAAXIH@Z";
    SetVoidPtr         :: (self: *Storage, key: ID, val: *void) #foreign imgui_lib "?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z";
}

StoragePair :: struct {
    key: ID;
}

Style :: struct {
    Alpha: float;
    WindowPadding: ImVec2;
    WindowRounding: float;
    WindowBorderSize: float;
    WindowMinSize: ImVec2;
    WindowTitleAlign: ImVec2;
    WindowMenuButtonPosition: Dir;
    ChildRounding: float;
    ChildBorderSize: float;
    PopupRounding: float;
    PopupBorderSize: float;
    FramePadding: ImVec2;
    FrameRounding: float;
    FrameBorderSize: float;
    ItemSpacing: ImVec2;
    ItemInnerSpacing: ImVec2;
    CellPadding: ImVec2;
    TouchExtraPadding: ImVec2;
    IndentSpacing: float;
    ColumnsMinSpacing: float;
    ScrollbarSize: float;
    ScrollbarRounding: float;
    GrabMinSize: float;
    GrabRounding: float;
    LogSliderDeadzone: float;
    TabRounding: float;
    TabBorderSize: float;
    TabMinWidthForCloseButton: float;
    ColorButtonPosition: Dir;
    ButtonTextAlign: ImVec2;
    SelectableTextAlign: ImVec2;
    DisplayWindowPadding: ImVec2;
    DisplaySafeAreaPadding: ImVec2;
    MouseCursorScale: float;
    AntiAliasedLines: bool;
    AntiAliasedLinesUseTex: bool;
    AntiAliasedFill: bool;
    CurveTessellationTol: float;
    CircleSegmentMaxError: float;
    Colors: [Col.COUNT]ImVec4;

    ScaleAllSizes     :: (self: *Style, scale_factor: float) #foreign imgui_lib "?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z";
}

StyleMod :: struct {
    VarIdx: StyleVar;
}

TabBar :: struct {
    Tabs: ImVector(TabItem);
    Flags: TabBarFlags;
    ID_: ID;
    SelectedTabId: ID;
    NextSelectedTabId: ID;
    VisibleTabId: ID;
    CurrFrameVisible: s32;
    PrevFrameVisible: s32;
    BarRect: ImRect;
    CurrTabsContentsHeight: float;
    PrevTabsContentsHeight: float;
    WidthAllTabs: float;
    WidthAllTabsIdeal: float;
    ScrollingAnim: float;
    ScrollingTarget: float;
    ScrollingTargetDistToVisibility: float;
    ScrollingSpeed: float;
    ScrollingRectMinX: float;
    ScrollingRectMaxX: float;
    ReorderRequestTabId: ID;
    ReorderRequestDir: s8;
    BeginCount: s8;
    WantLayout: bool;
    VisibleTabWasSubmitted: bool;
    TabsAddedNew: bool;
    TabsActiveCount: s16;
    LastTabItemIdx: s16;
    ItemSpacingY: float;
    FramePadding: ImVec2;
    BackupCursorPos: ImVec2;
    TabsNames: TextBuffer;
}

TabItem :: struct {
    ID_: ID;
    Flags: TabItemFlags;
    Window_: *Window;
    LastFrameVisible: s32;
    LastFrameSelected: s32;
    Offset: float;
    Width: float;
    ContentWidth: float;
    NameOffset: s16;
    BeginOrder: s16;
    IndexDuringLayout: s16;
    WantClose: bool;
}

Table :: struct {
    ID_: ID;
    Flags: TableFlags;
    RawData: *void;
    Columns: ImSpan(TableColumn);
    DisplayOrderToIndex: ImSpan(TableColumnIdx);
    RowCellData: ImSpan(TableCellData);
    EnabledMaskByDisplayOrder: u64;
    EnabledMaskByIndex: u64;
    VisibleMaskByIndex: u64;
    RequestOutputMaskByIndex: u64;
    SettingsLoadedFlags: TableFlags;
    SettingsOffset: s32;
    LastFrameActive: s32;
    ColumnsCount: s32;
    CurrentRow: s32;
    CurrentColumn: s32;
    InstanceCurrent: s16;
    InstanceInteracted: s16;
    RowPosY1: float;
    RowPosY2: float;
    RowMinHeight: float;
    RowTextBaseline: float;
    RowIndentOffsetX: float;
    RowFlags: TableRowFlags;
    LastRowFlags: TableRowFlags;
    RowBgColorCounter: s32;
    RowBgColor: [2]u32;
    BorderColorStrong: u32;
    BorderColorLight: u32;
    BorderX1: float;
    BorderX2: float;
    HostIndentX: float;
    OuterPaddingX: float;
    CellPaddingX: float;
    CellPaddingY: float;
    CellSpacingX1: float;
    CellSpacingX2: float;
    LastOuterHeight: float;
    LastFirstRowHeight: float;
    InnerWidth: float;
    ColumnsTotalWidth: float;
    ColumnsAutoFitWidth: float;
    ResizedColumnNextWidth: float;
    RefScale: float;
    OuterRect: ImRect;
    WorkRect: ImRect;
    InnerClipRect: ImRect;
    BgClipRect: ImRect;
    BgClipRectForDrawCmd: ImRect;
    HostClipRect: ImRect;
    HostBackupWorkRect: ImRect;
    HostBackupParentWorkRect: ImRect;
    HostBackupClipRect: ImRect;
    HostBackupPrevLineSize: ImVec2;
    HostBackupCurrLineSize: ImVec2;
    HostBackupCursorMaxPos: ImVec2;
    HostBackupColumnsOffset: ImVec1;
    HostBackupItemWidth: float;
    HostBackupItemWidthStackSize: s32;
    OuterWindow: *Window;
    InnerWindow: *Window;
    ColumnsNames: TextBuffer;
    DrawSplitter: ImDrawListSplitter;
    SortSpecsSingle: TableColumnSortSpecs;
    SortSpecsMulti: ImVector(TableColumnSortSpecs);
    SortSpecs: TableSortSpecs;
    SortSpecsCount: TableColumnIdx;
    ColumnsEnabledCount: TableColumnIdx;
    ColumnsEnabledFixedCount: TableColumnIdx;
    DeclColumnsCount: TableColumnIdx;
    HoveredColumnBody: TableColumnIdx;
    HoveredColumnBorder: TableColumnIdx;
    AutoFitSingleStretchColumn: TableColumnIdx;
    ResizedColumn: TableColumnIdx;
    LastResizedColumn: TableColumnIdx;
    HeldHeaderColumn: TableColumnIdx;
    ReorderColumn: TableColumnIdx;
    ReorderColumnDir: TableColumnIdx;
    RightMostEnabledColumn: TableColumnIdx;
    LeftMostStretchedColumnDisplayOrder: TableColumnIdx;
    ContextPopupColumn: TableColumnIdx;
    FreezeRowsRequest: TableColumnIdx;
    FreezeRowsCount: TableColumnIdx;
    FreezeColumnsRequest: TableColumnIdx;
    FreezeColumnsCount: TableColumnIdx;
    RowCellDataCurrent: TableColumnIdx;
    DummyDrawChannel: TableDrawChannelIdx;
    Bg1DrawChannelCurrent: TableDrawChannelIdx;
    Bg1DrawChannelUnfrozen: TableDrawChannelIdx;
    IsLayoutLocked: bool;
    IsInsideRow: bool;
    IsInitializing: bool;
    IsSortSpecsDirty: bool;
    IsUsingHeaders: bool;
    IsContextPopupOpen: bool;
    IsSettingsRequestLoad: bool;
    IsSettingsDirty: bool;
    IsDefaultDisplayOrder: bool;
    IsResetAllRequest: bool;
    IsResetDisplayOrderRequest: bool;
    IsUnfrozen: bool;
    MemoryCompacted: bool;
    HostSkipItems: bool;
}

TableCellData :: struct {
    BgColor: u32;
    Column: TableColumnIdx;
}

TableColumn :: struct {
    ClipRect: ImRect;
    UserID: ID;
    Flags: TableColumnFlags;
    MinX: float;
    MaxX: float;
    InitStretchWeightOrWidth: float;
    StretchWeight: float;
    WidthAuto: float;
    WidthRequest: float;
    WidthGiven: float;
    WorkMinX: float;
    WorkMaxX: float;
    ItemWidth: float;
    ContentMaxXFrozen: float;
    ContentMaxXUnfrozen: float;
    ContentMaxXHeadersUsed: float;
    ContentMaxXHeadersIdeal: float;
    NameOffset: s16;
    DisplayOrder: TableColumnIdx;
    IndexWithinEnabledSet: TableColumnIdx;
    PrevEnabledColumn: TableColumnIdx;
    NextEnabledColumn: TableColumnIdx;
    SortOrder: TableColumnIdx;
    DrawChannelCurrent: TableDrawChannelIdx;
    DrawChannelFrozen: TableDrawChannelIdx;
    DrawChannelUnfrozen: TableDrawChannelIdx;
    IsEnabled: bool;
    IsEnabledNextFrame: bool;
    IsVisibleX: bool;
    IsVisibleY: bool;
    IsRequestOutput: bool;
    IsSkipItems: bool;
    IsPreserveWidthAuto: bool;
    NavLayerCurrent: s8;
    AutoFitQueue: u8;
    CannotSkipItemsQueue: u8;
    SortDirection: u8;
    SortDirectionsAvailCount: u8;
    SortDirectionsAvailMask: u8;
    SortDirectionsAvailList: u8;
}

TableColumnSettings :: struct {
    WidthOrWeight: float;
    UserID: ID;
    Index: TableColumnIdx;
    DisplayOrder: TableColumnIdx;
    SortOrder: TableColumnIdx;
    SortDirection: u8;
    IsEnabled: u8;
    IsStretch: u8;
}

TableColumnSortSpecs :: struct {
    ColumnUserID: ID;
    ColumnIndex: s16;
    SortOrder: s16;
    SortDirection_: SortDirection;
}

TableSettings :: struct {
    ID_: ID;
    SaveFlags: TableFlags;
    RefScale: float;
    ColumnsCount: TableColumnIdx;
    ColumnsCountMax: TableColumnIdx;
    WantApply: bool;
}

TableSortSpecs :: struct {
    Specs: *TableColumnSortSpecs;
    SpecsCount: s32;
    SpecsDirty: bool;
}

TextBuffer :: struct {
    Buf: ImVector(s8);

    append      :: (self: *TextBuffer, str: string) {
    _internal_append :: (self: *TextBuffer, str: *u8, str_end: *u8) #foreign imgui_lib "?append@ImGuiTextBuffer@@QEAAXPEBD0@Z";
    _internal_append(self, str.data, str.data + str.count);
}
    appendf     :: (self: *TextBuffer, fmt: *u8, args: ..Any) #foreign imgui_lib "?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ";
}

TextFilter :: struct {
    InputBuf: [256]s8;
    Filters: ImVector(TextRange);
    CountGrep: s32;

    Build          :: (self: *TextFilter) #foreign imgui_lib "?Build@ImGuiTextFilter@@QEAAXXZ";
    Draw           :: (self: *TextFilter, label: *u8 = "Filter(inc,-exc)", width: float = 0.0) -> bool #foreign imgui_lib "?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z";
    PassFilter     :: (self: *TextFilter, text: string) -> bool {
    _internal_PassFilter :: (self: *TextFilter, text: *u8, text_end: *u8) -> bool #foreign imgui_lib "?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z";
    return _internal_PassFilter(self, text.data, text.data + text.count);
}
}

TextRange :: struct {
    b: *u8;
    e: *u8;
}

Viewport :: struct {
    ID_: ID;
    Flags: ViewportFlags;
    Pos: ImVec2;
    Size: ImVec2;
    WorkOffsetMin: ImVec2;
    WorkOffsetMax: ImVec2;
    DpiScale: float;
    DrawData: *ImDrawData;
    ParentViewportId: ID;
    RendererUserData: *void;
    PlatformUserData: *void;
    PlatformHandle: *void;
    PlatformHandleRaw: *void;
    PlatformRequestMove: bool;
    PlatformRequestResize: bool;
    PlatformRequestClose: bool;
    GetCenter      :: (using self: *Viewport) -> ImVec2 { return make_ImVec2(Pos.x + Size.x * 0.5, Pos.y + Size.y * 0.5); }
    GetWorkPos     :: (using self: *Viewport) -> ImVec2 { return make_ImVec2(Pos.x + WorkOffsetMin.x, Pos.y + WorkOffsetMin.y); }
    GetWorkSize    :: (using self: *Viewport) -> ImVec2 { return make_ImVec2(Size.x - WorkOffsetMin.x + WorkOffsetMax.x, Size.y - WorkOffsetMin.y + WorkOffsetMax.y); } // This not clamped
}

ViewportP :: struct {
    _ImGuiViewport: Viewport;
    Idx: s32;
    LastFrameActive: s32;
    LastFrameDrawLists: [2]s32;
    LastFrontMostStampCount: s32;
    LastNameHash: ID;
    LastPos: ImVec2;
    Alpha: float;
    LastAlpha: float;
    PlatformMonitor: s16;
    PlatformWindowCreated: bool;
    Window_: *Window;
    DrawLists: [2]*ImDrawList;
    DrawDataP: ImDrawData;
    DrawDataBuilder: ImDrawDataBuilder;
    LastPlatformPos: ImVec2;
    LastPlatformSize: ImVec2;
    LastRendererSize: ImVec2;
    CurrWorkOffsetMin: ImVec2;
    CurrWorkOffsetMax: ImVec2;
}

Window :: struct {
    Name: *u8;
    ID_: ID;
    Flags: WindowFlags;
    FlagsPreviousFrame: WindowFlags;
    WindowClass_: WindowClass;
    Viewport: *ViewportP;
    ViewportId: ID;
    ViewportPos: ImVec2;
    ViewportAllowPlatformMonitorExtend: s32;
    Pos: ImVec2;
    Size: ImVec2;
    SizeFull: ImVec2;
    ContentSize: ImVec2;
    ContentSizeExplicit: ImVec2;
    WindowPadding: ImVec2;
    WindowRounding: float;
    WindowBorderSize: float;
    NameBufLen: s32;
    MoveId: ID;
    ChildId: ID;
    Scroll: ImVec2;
    ScrollMax: ImVec2;
    ScrollTarget: ImVec2;
    ScrollTargetCenterRatio: ImVec2;
    ScrollTargetEdgeSnapDist: ImVec2;
    ScrollbarSizes: ImVec2;
    ScrollbarX: bool;
    ScrollbarY: bool;
    ViewportOwned: bool;
    Active: bool;
    WasActive: bool;
    WriteAccessed: bool;
    Collapsed: bool;
    WantCollapseToggle: bool;
    SkipItems: bool;
    Appearing: bool;
    Hidden: bool;
    IsFallbackWindow: bool;
    HasCloseButton: bool;
    ResizeBorderHeld: s8;
    BeginCount: s16;
    BeginOrderWithinParent: s16;
    BeginOrderWithinContext: s16;
    PopupId: ID;
    AutoFitFramesX: s8;
    AutoFitFramesY: s8;
    AutoFitChildAxises: s8;
    AutoFitOnlyGrows: bool;
    AutoPosLastDirection: Dir;
    HiddenFramesCanSkipItems: s8;
    HiddenFramesCannotSkipItems: s8;
    HiddenFramesForRenderOnly: s8;
    SetWindowPosAllowFlags: Cond;
    SetWindowSizeAllowFlags: Cond;
    SetWindowCollapsedAllowFlags: Cond;
    SetWindowDockAllowFlags: Cond;
    SetWindowPosVal: ImVec2;
    SetWindowPosPivot: ImVec2;
    IDStack: ImVector(ID);
    DC: WindowTempData;
    OuterRectClipped: ImRect;
    InnerRect: ImRect;
    InnerClipRect: ImRect;
    WorkRect: ImRect;
    ParentWorkRect: ImRect;
    ClipRect: ImRect;
    ContentRegionRect: ImRect;
    HitTestHoleSize: ImVec2ih;
    HitTestHoleOffset: ImVec2ih;
    LastFrameActive: s32;
    LastFrameJustFocused: s32;
    LastTimeActive: float;
    ItemWidthDefault: float;
    StateStorage: Storage;
    ColumnsStorage: ImVector(OldColumns);
    FontWindowScale: float;
    FontDpiScale: float;
    SettingsOffset: s32;
    DrawList: *ImDrawList;
    DrawListInst: ImDrawList;
    ParentWindow: *Window;
    RootWindow: *Window;
    RootWindowDockStop: *Window;
    RootWindowForTitleBarHighlight: *Window;
    RootWindowForNav: *Window;
    NavLastChildNavWindow: *Window;
    NavLastIds: [NavLayer.COUNT]ID;
    NavRectRel: [NavLayer.COUNT]ImRect;
    MemoryDrawListIdxCapacity: s32;
    MemoryDrawListVtxCapacity: s32;
    MemoryCompacted: bool;
    DockNode_: *DockNode;
    DockNodeAsHost: *DockNode;
    DockId: ID;
    DockTabItemStatusFlags: ItemStatusFlags;
    DockTabItemRect: ImRect;
    DockOrder: s16;
    DockIsActive: bool;
    DockTabIsVisible: bool;
    DockTabWantClose: bool;

    CalcFontSize           :: (self: *Window) -> float #foreign imgui_lib "?CalcFontSize@ImGuiWindow@@QEBAMXZ";
    GetID                  :: (self: *Window, str: string) -> ID {
    _internal_GetID :: (self: *Window, str: *u8, str_end: *u8) -> ID #foreign imgui_lib "?GetID@ImGuiWindow@@QEAAIPEBD0@Z";
    return _internal_GetID(self, str.data, str.data + str.count);
}
    GetID                  :: (self: *Window, ptr: *void) -> ID #foreign imgui_lib "?GetID@ImGuiWindow@@QEAAIPEBX@Z";
    GetID                  :: (self: *Window, n: s32) -> ID #foreign imgui_lib "?GetID@ImGuiWindow@@QEAAIH@Z";
    GetIDFromRectangle     :: (self: *Window, r_abs: ImRect) -> ID {
    _internal_GetIDFromRectangle :: (self: *Window, r_abs: *ImRect) -> ID #foreign imgui_lib "?GetIDFromRectangle@ImGuiWindow@@QEAAIAEBUImRect@@@Z";
    return _internal_GetIDFromRectangle(self, *r_abs);
}
    GetIDNoKeepAlive       :: (self: *Window, str: string) -> ID {
    _internal_GetIDNoKeepAlive :: (self: *Window, str: *u8, str_end: *u8) -> ID #foreign imgui_lib "?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBD0@Z";
    return _internal_GetIDNoKeepAlive(self, str.data, str.data + str.count);
}
    GetIDNoKeepAlive       :: (self: *Window, ptr: *void) -> ID #foreign imgui_lib "?GetIDNoKeepAlive@ImGuiWindow@@QEAAIPEBX@Z";
    GetIDNoKeepAlive       :: (self: *Window, n: s32) -> ID #foreign imgui_lib "?GetIDNoKeepAlive@ImGuiWindow@@QEAAIH@Z";
    MenuBarHeight          :: (self: *Window) -> float #foreign imgui_lib "?MenuBarHeight@ImGuiWindow@@QEBAMXZ";
    TitleBarHeight         :: (self: *Window) -> float #foreign imgui_lib "?TitleBarHeight@ImGuiWindow@@QEBAMXZ";
}

WindowClass :: struct {
    ClassId: ID;
    ParentViewportId: ID;
    ViewportFlagsOverrideSet: ViewportFlags;
    ViewportFlagsOverrideClear: ViewportFlags;
    DockNodeFlagsOverrideSet: DockNodeFlags;
    DockNodeFlagsOverrideClear: DockNodeFlags;
    DockingAlwaysTabBar: bool;
    DockingAllowUnclassed: bool;
}

WindowSettings :: struct {
    ID_: ID;
    Pos: ImVec2ih;
    Size: ImVec2ih;
    ViewportPos: ImVec2ih;
    ViewportId: ID;
    DockId: ID;
    ClassId: ID;
    DockOrder: s16;
    Collapsed: bool;
    WantApply: bool;
}

WindowTempData :: struct {
    CursorPos: ImVec2;
    CursorPosPrevLine: ImVec2;
    CursorStartPos: ImVec2;
    CursorMaxPos: ImVec2;
    CurrLineSize: ImVec2;
    PrevLineSize: ImVec2;
    CurrLineTextBaseOffset: float;
    PrevLineTextBaseOffset: float;
    Indent: ImVec1;
    ColumnsOffset: ImVec1;
    GroupOffset: ImVec1;
    LastItemId: ID;
    LastItemStatusFlags: ItemStatusFlags;
    LastItemRect: ImRect;
    LastItemDisplayRect: ImRect;
    NavLayerCurrent: NavLayer;
    NavLayerActiveMask: s32;
    NavLayerActiveMaskNext: s32;
    NavFocusScopeIdCurrent: ID;
    NavHideHighlightOneFrame: bool;
    NavHasScroll: bool;
    MenuBarAppending: bool;
    MenuBarOffset: ImVec2;
    MenuColumns_: MenuColumns;
    TreeDepth: s32;
    TreeJumpToParentOnPopMask: u32;
    ChildWindows: ImVector(*Window);
    StateStorage: *Storage;
    CurrentColumns: *OldColumns;
    CurrentTableIdx: s32;
    LayoutType_: LayoutType;
    ParentLayoutType: LayoutType;
    FocusCounterRegular: s32;
    FocusCounterTabStop: s32;
    ItemFlags_: ItemFlags;
    ItemWidth: float;
    TextWrapPos: float;
    ItemWidthStack: ImVector(float);
    TextWrapPosStack: ImVector(float);
    StackSizesOnBegin: StackSizes;
}

ImRect :: struct {
    Min: ImVec2;
    Max: ImVec2;

    Add              :: (self: *ImRect, p: ImVec2) {
    _internal_Add :: (self: *ImRect, p: *ImVec2) #foreign imgui_lib "?Add@ImRect@@QEAAXAEBUImVec2@@@Z";
    _internal_Add(self, *p);
}
    Add              :: (self: *ImRect, r: ImRect) {
    _internal_Add :: (self: *ImRect, r: *ImRect) #foreign imgui_lib "?Add@ImRect@@QEAAXAEBU1@@Z";
    _internal_Add(self, *r);
}
    ClipWith         :: (self: *ImRect, r: ImRect) {
    _internal_ClipWith :: (self: *ImRect, r: *ImRect) #foreign imgui_lib "?ClipWith@ImRect@@QEAAXAEBU1@@Z";
    _internal_ClipWith(self, *r);
}
    ClipWithFull     :: (self: *ImRect, r: ImRect) {
    _internal_ClipWithFull :: (self: *ImRect, r: *ImRect) #foreign imgui_lib "?ClipWithFull@ImRect@@QEAAXAEBU1@@Z";
    _internal_ClipWithFull(self, *r);
}
    Contains         :: (self: *ImRect, p: ImVec2) -> bool {
    _internal_Contains :: (self: *ImRect, p: *ImVec2) -> bool #foreign imgui_lib "?Contains@ImRect@@QEBA_NAEBUImVec2@@@Z";
    return _internal_Contains(self, *p);
}
    Contains         :: (self: *ImRect, r: ImRect) -> bool {
    _internal_Contains :: (self: *ImRect, r: *ImRect) -> bool #foreign imgui_lib "?Contains@ImRect@@QEBA_NAEBU1@@Z";
    return _internal_Contains(self, *r);
}
    Expand           :: (self: *ImRect, amount: float) #foreign imgui_lib "?Expand@ImRect@@QEAAXM@Z";
    Expand           :: (self: *ImRect, amount: ImVec2) {
    _internal_Expand :: (self: *ImRect, amount: *ImVec2) #foreign imgui_lib "?Expand@ImRect@@QEAAXAEBUImVec2@@@Z";
    _internal_Expand(self, *amount);
}
    Floor            :: (self: *ImRect) #foreign imgui_lib "?Floor@ImRect@@QEAAXXZ";
    GetHeight        :: (self: *ImRect) -> float #foreign imgui_lib "?GetHeight@ImRect@@QEBAMXZ";
    GetWidth         :: (self: *ImRect) -> float #foreign imgui_lib "?GetWidth@ImRect@@QEBAMXZ";
    IsInverted       :: (self: *ImRect) -> bool #foreign imgui_lib "?IsInverted@ImRect@@QEBA_NXZ";
    Overlaps         :: (self: *ImRect, r: ImRect) -> bool {
    _internal_Overlaps :: (self: *ImRect, r: *ImRect) -> bool #foreign imgui_lib "?Overlaps@ImRect@@QEBA_NAEBU1@@Z";
    return _internal_Overlaps(self, *r);
}
    Translate        :: (self: *ImRect, d: ImVec2) {
    _internal_Translate :: (self: *ImRect, d: *ImVec2) #foreign imgui_lib "?Translate@ImRect@@QEAAXAEBUImVec2@@@Z";
    _internal_Translate(self, *d);
}
    TranslateX       :: (self: *ImRect, dx: float) #foreign imgui_lib "?TranslateX@ImRect@@QEAAXM@Z";
    TranslateY       :: (self: *ImRect, dy: float) #foreign imgui_lib "?TranslateY@ImRect@@QEAAXM@Z";
}

ImVec1 :: struct {
    x: float;
}

ImVec2 :: struct {
    x: float;
    y: float;
}

ImVec2ih :: struct {
    x: s16;
    y: s16;
}

ImVec4 :: struct {
    x: float;
    y: float;
    z: float;
    w: float;
}

STB_TexteditState :: struct {
    cursor: s32;
    select_start: s32;
    select_end: s32;
    insert_mode: u8;
    row_count_per_page: s32;
    cursor_at_end_of_line: u8;
    initialized: u8;
    has_preferred_x: u8;
    single_line: u8;
    padding1: u8;
    padding2: u8;
    padding3: u8;
    preferred_x: float;
    undostate: StbUndoState;
}

StbTexteditRow :: struct {
    x0: float;
    x1: float;
    baseline_y_delta: float;
    ymin: float;
    ymax: float;
    num_chars: s32;
}

StbUndoRecord :: struct {
    where: s32;
    insert_length: s32;
    delete_length: s32;
    char_storage: s32;
}

StbUndoState :: struct {
    undo_rec: [99]StbUndoRecord;
    undo_char: [999]ImWchar;
    undo_point: s16;
    redo_point: s16;
    undo_char_point: s32;
    redo_char_point: s32;
}



ImSpan :: struct(T: Type) {
    Data:    *T;
    DataEnd: *T;
}

ImVector :: struct(T: Type) {
    Size:     s32;
    Capacity: s32;
    Data:     *T;
}

ImPool :: struct(T: Type) {
    Buf: ImVector(T);
    Map: Storage;
    FreeIdx: ImPoolIdx;
}

ImChunkStream :: struct(T: Type) {
    Buf: ImVector(s8);
}

ImPoolIdx :: s32;
ImTextureID :: *void;
ImDrawIdx :: u16;
ImFileHandle :: *void;
ImGuiID :: u32;
ID :: u32;
TableDrawChannelIdx :: u8;
TableColumnIdx :: s8;
DockNodeSettings :: struct {};
DockRequest :: struct {};
ContextHookCallback :: #type (ctx: *Context, hook: *ContextHook) #c_call;
ImDrawCallback :: #type (parent_list: *ImDrawList, cmd: *ImDrawCmd) #c_call;
InputTextCallback :: #type (data: *InputTextCallbackData) -> s32 #c_call;
SizeCallback :: #type (data: *SizeCallbackData) #c_call;
ImWchar16 :: u16;
ImWchar32 :: u32;

IMGUI_USE_WCHAR32 :: false; // TODO: Module parameter

#if IMGUI_USE_WCHAR32
    ImWchar :: ImWchar32;
else
    ImWchar :: ImWchar16;

make_ImVec2 :: inline (a: float, b: float) -> ImVec2 {
    v: ImVec2 = ---;
    v.x = a;
    v.y = b;
    return v;
}

TreeNode :: (fmt: string, args: ..Any) -> bool {
    fmt_z := tprint("%\0", fmt);
    txt := tprint(fmt_z, ..args);
    return TreeNode(txt.data);
}

IM_COL32_R_SHIFT  ::  0;
IM_COL32_G_SHIFT  ::  8;
IM_COL32_B_SHIFT  ::  16;
IM_COL32_A_SHIFT  ::  24;
IM_COL32_A_MASK   ::  0xFF000000;
// This is a C preprocessor macro, should it be a Jai macro?
make_col32 :: (R : u32, G: u32, B: u32, A: u32) -> u32 {
    return cast(u32)((A<<IM_COL32_A_SHIFT) | (B<<IM_COL32_B_SHIFT) | 
        (G<<IM_COL32_G_SHIFT) | (R<<IM_COL32_R_SHIFT));
}
make_col32 :: (c: ImVec4) -> u32 {
    return make_col32(xx(c.x * 255), xx(c.y * 255), xx(c.z * 255), xx(c.w * 255));
}

#scope_file

#import "Basic";

FLT_MAX :: 0h7F7FFFFF;

#if OS == .WINDOWS
    #if LINK_STATIC {
        imgui_lib :: #foreign_library,no_dll "win/static/imgui";
    } else {
        imgui_lib :: #foreign_library "win/dll/imgui";
    }
else
    #assert false, "TODO: implement this platform!";


