//
// AUTOGENERATED
//

RendererApi :: enum {
    D3D12 :: 0;
	VULKAN;
	METAL;
	XBOX_D3D12;
	D3D11;
	ORBIS;
	PROSPERO;
}

LogType :: enum {
    INFO :: 0;
	WARN;
	DEBUG;
	ERROR;
}

QueueType :: enum {
    GRAPHICS :: 0;
	TRANSFER;
	COMPUTE;
	MAX_QUEUE_TYPE;
}

QueueFlag :: enum_flags {
    NONE :: 0x0;
	DISABLE_GPU_TIMEOUT :: 0x1;
	INIT_MICROPROFILE :: 0x2;
	MAX_QUEUE_FLAG :: 0xFFFFFFFF;
}

QueuePriority :: enum {
    NORMAL;
	HIGH;
	GLOBAL_REALTIME;
	MAX_QUEUE_PRIORITY;
}

LoadActionType :: enum {
    DONTCARE;
	LOAD;
	CLEAR;
	MAX_LOAD_ACTION;
}

ResourceState :: enum_flags {
    UNDEFINED :: 0;
	VERTEX_AND_CONSTANT_BUFFER :: 0x1;
	INDEX_BUFFER :: 0x2;
	RENDER_TARGET :: 0x4;
	UNORDERED_ACCESS :: 0x8;
	DEPTH_WRITE :: 0x10;
	DEPTH_READ :: 0x20;
	NON_PIXEL_SHADER_RESOURCE :: 0x40;
	PIXEL_SHADER_RESOURCE :: 0x80;
	SHADER_RESOURCE :: 0x40 | 0x80;
	STREAM_OUT :: 0x100;
	INDIRECT_ARGUMENT :: 0x200;
	COPY_DEST :: 0x400;
	COPY_SOURCE :: 0x800;
	GENERIC_READ :: (((((0x1 | 0x2) | 0x40) | 0x80) | 0x200) | 0x800);
	PRESENT :: 0x1000;
	COMMON :: 0x2000;
	RAYTRACING_ACCELERATION_STRUCTURE :: 0x4000;
}

ResourceMemoryUsage :: enum {
    /// No intended memory usage specified.
	UNKNOWN :: 0;
	/// Memory will be used on device only; no need to be mapped on host.
	GPU_ONLY :: 1;
	/// Memory will be mapped on host. Could be used for transfer to device.
	CPU_ONLY :: 2;
	/// Memory will be used for frequent (dynamic) updates from host and reads on device.
	CPU_TO_GPU :: 3;
	/// Memory will be used for writing on device and readback on host.
	GPU_TO_CPU :: 4;
	COUNT;
	MAX_ENUM :: 0x7FFFFFFF;
}

IndirectArgumentType :: enum {
    INDIRECT_DRAW;
	INDIRECT_DRAW_INDEX;
	INDIRECT_DISPATCH;
	INDIRECT_VERTEX_BUFFER;
	INDIRECT_INDEX_BUFFER;
	INDIRECT_CONSTANT;
	INDIRECT_DESCRIPTOR_TABLE;        // only for vulkan
	INDIRECT_PIPELINE;                // only for vulkan now; probally will add to dx when it comes to xbox
	INDIRECT_CONSTANT_BUFFER_VIEW;    // only for dx
	INDIRECT_SHADER_RESOURCE_VIEW;    // only for dx
	INDIRECT_UNORDERED_ACCESS_VIEW;   // only for dx
#if defined(METAL)
	INDIRECT_COMMAND_BUFFER;          // metal ICB
	INDIRECT_COMMAND_BUFFER_RESET;    // metal ICB reset
	INDIRECT_COMMAND_BUFFER_OPTIMIZE  // metal ICB optimization
#endif;
}

DescriptorType :: enum_flags {
    DESCRIPTOR_TYPE_UNDEFINED :: 0;
	DESCRIPTOR_TYPE_SAMPLER :: 0x01;
	// SRV Read only texture
	DESCRIPTOR_TYPE_TEXTURE :: (DESCRIPTOR_TYPE_SAMPLER << 1);
	/// UAV Texture
	DESCRIPTOR_TYPE_RW_TEXTURE :: (DESCRIPTOR_TYPE_TEXTURE << 1);
	// SRV Read only buffer
	DESCRIPTOR_TYPE_BUFFER :: (DESCRIPTOR_TYPE_RW_TEXTURE << 1);
	DESCRIPTOR_TYPE_BUFFER_RAW :: (DESCRIPTOR_TYPE_BUFFER | (DESCRIPTOR_TYPE_BUFFER << 1));
	/// UAV Buffer
	DESCRIPTOR_TYPE_RW_BUFFER :: (DESCRIPTOR_TYPE_BUFFER << 2);
	DESCRIPTOR_TYPE_RW_BUFFER_RAW :: (DESCRIPTOR_TYPE_RW_BUFFER | (DESCRIPTOR_TYPE_RW_BUFFER << 1));
	/// Uniform buffer
	DESCRIPTOR_TYPE_UNIFORM_BUFFER :: (DESCRIPTOR_TYPE_RW_BUFFER << 2);
	/// Push constant / Root constant
	DESCRIPTOR_TYPE_ROOT_CONSTANT :: (DESCRIPTOR_TYPE_UNIFORM_BUFFER << 1);
	/// IA
	DESCRIPTOR_TYPE_VERTEX_BUFFER :: (DESCRIPTOR_TYPE_ROOT_CONSTANT << 1);
	DESCRIPTOR_TYPE_INDEX_BUFFER :: (DESCRIPTOR_TYPE_VERTEX_BUFFER << 1);
	DESCRIPTOR_TYPE_INDIRECT_BUFFER :: (DESCRIPTOR_TYPE_INDEX_BUFFER << 1);
	/// Cubemap SRV
	DESCRIPTOR_TYPE_TEXTURE_CUBE :: (DESCRIPTOR_TYPE_TEXTURE | (DESCRIPTOR_TYPE_INDIRECT_BUFFER << 1));
	/// RTV / DSV per mip slice
	DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES :: (DESCRIPTOR_TYPE_INDIRECT_BUFFER << 2);
	/// RTV / DSV per array slice
	DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES :: (DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES << 1);
	/// RTV / DSV per depth slice
	DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES :: (DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES << 1);
	DESCRIPTOR_TYPE_RAY_TRACING :: (DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES << 1);
#if defined(VULKAN)
	/// Subpass input (descriptor type only available in Vulkan)
	DESCRIPTOR_TYPE_INPUT_ATTACHMENT :: (DESCRIPTOR_TYPE_RAY_TRACING << 1);
	DESCRIPTOR_TYPE_TEXEL_BUFFER :: (DESCRIPTOR_TYPE_INPUT_ATTACHMENT << 1);
	DESCRIPTOR_TYPE_RW_TEXEL_BUFFER :: (DESCRIPTOR_TYPE_TEXEL_BUFFER << 1);
#endif
#if defined(METAL)
    DESCRIPTOR_TYPE_ARGUMENT_BUFFER :: (DESCRIPTOR_TYPE_RAY_TRACING << 1);
    DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER :: (DESCRIPTOR_TYPE_ARGUMENT_BUFFER << 1);
    DESCRIPTOR_TYPE_RENDER_PIPELINE_STATE :: (DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER << 1);
#endif;
}

SampleCount :: enum {
    1 :: 1;
	2 :: 2;
	4 :: 4;
	8 :: 8;
	16 :: 16;
}

ShaderStage :: enum_flags {
    NONE :: 0;
	VERT :: 0X00000001;
	FRAG :: 0X00000002;
	COMP :: 0X00000004;
	ALL_GRAPHICS :: ((uint32_t)VERT | (uint32_t)FRAG);
	COUNT :: 3;
}

ShaderStage :: enum_flags {
    NONE :: 0;
	VERT :: 0X00000001;
	TESC :: 0X00000002;
	TESE :: 0X00000004;
	GEOM :: 0X00000008;
	FRAG :: 0X00000010;
	COMP :: 0X00000020;
	RAYTRACING  :: 0X00000040;
	ALL_GRAPHICS :: ((uint32_t)VERT | (uint32_t)TESC | (uint32_t)TESE | (uint32_t)GEOM | (uint32_t)FRAG);
	HULL :: TESC;
	DOMN :: TESE;
	COUNT :: 7;
}

PrimitiveTopology :: enum {
    POINT_LIST :: 0;
	LINE_LIST;
	LINE_STRIP;
	TRI_LIST;
	TRI_STRIP;
	PATCH_LIST;
	COUNT;
}

IndexType :: enum {
    32 :: 0;
	16;
}

ShaderSemantic :: enum {
    UNDEFINED :: 0;
	POSITION;
	NORMAL;
	COLOR;
	TANGENT;
	BITANGENT;
	JOINTS;
	WEIGHTS;
	TEXCOORD0;
	TEXCOORD1;
	TEXCOORD2;
	TEXCOORD3;
	TEXCOORD4;
	TEXCOORD5;
	TEXCOORD6;
	TEXCOORD7;
	TEXCOORD8;
	TEXCOORD9;
}

BlendConstant :: enum {
    ZERO :: 0;
	ONE;
	SRC_COLOR;
	ONE_MINUS_SRC_COLOR;
	DST_COLOR;
	ONE_MINUS_DST_COLOR;
	SRC_ALPHA;
	ONE_MINUS_SRC_ALPHA;
	DST_ALPHA;
	ONE_MINUS_DST_ALPHA;
	SRC_ALPHA_SATURATE;
	BLEND_FACTOR;
	ONE_MINUS_BLEND_FACTOR;
	MAX_BLEND_CONSTANTS;
}

BlendMode :: enum {
    ADD;
	SUBTRACT;
	REVERSE_SUBTRACT;
	MIN;
	MAX;
	MAX_BLEND_MODES;
}

CompareMode :: enum {
    NEVER;
	LESS;
	EQUAL;
	LEQUAL;
	GREATER;
	NOTEQUAL;
	GEQUAL;
	ALWAYS;
	MAX_COMPARE_MODES;
}

StencilOp :: enum {
    KEEP;
	SET_ZERO;
	REPLACE;
	INVERT;
	INCR;
	DECR;
	INCR_SAT;
	DECR_SAT;
	MAX_STENCIL_OPS;
}

BlendStateTargets :: enum_flags {
    0 :: 0x1;
	1 :: 0x2;
	2 :: 0x4;
	3 :: 0x8;
	4 :: 0x10;
	5 :: 0x20;
	6 :: 0x40;
	7 :: 0x80;
	ALL :: 0xFF;
}

CullMode :: enum {
    NONE :: 0;
	BACK;
	FRONT;
	BOTH;
	MAX_CULL_MODES;
}

FrontFace :: enum {
    CW :: 0;
	W;
}

FillMode :: enum {
    SOLID;
	WIREFRAME;
	MAX_FILL_MODES;
}

PipelineType :: enum {
    UNDEFINED :: 0;
	COMPUTE;
	GRAPHICS;
	RAYTRACING;
	COUNT;
}

FilterType :: enum {
    NEAREST :: 0;
	LINEAR;
}

AddressMode :: enum {
    MIRROR;
	REPEAT;
	CLAMP_TO_EDGE;
	CLAMP_TO_BORDER;
}

MipMapMode :: enum {
    NEAREST :: 0;
	LINEAR;
}

DepthStencilClearFlags :: enum_flags {
    ClEAR_DEPTH :: 0x01;
	STENCIL :: 0x02;
}

BufferCreationFlags :: enum_flags {
    /// Default flag (Buffer will use aliased memory; buffer will not be cpu accessible until mapBuffer is called)
	BUFFER_CREATION_FLAG_NONE :: 0x01;
	/// Buffer will allocate its own memory (COMMITTED resource)
	BUFFER_CREATION_FLAG_OWN_MEMORY_BIT :: 0x02;
	/// Buffer will be persistently mapped
	BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT :: 0x04;
	/// Use ESRAM to store this buffer
	BUFFER_CREATION_FLAG_ESRAM :: 0x08;
	/// Flag to specify not to allocate descriptors for the resource
	BUFFER_CREATION_FLAG_NO_DESCRIPTOR_VIEW_CREATION :: 0x10;
    
#ifdef METAL
    /* ICB Flags */
    /// Ihnerit pipeline in ICB
    BUFFER_CREATION_FLAG_ICB_INHERIT_PIPELINE :: 0x100;
    /// Ihnerit pipeline in ICB
    BUFFER_CREATION_FLAG_ICB_INHERIT_BUFFERS :: 0x200;
    
#endif;
}

TextureCreationFlags :: enum_flags {
    /// Default flag (Texture will use default allocation strategy decided by the api specific allocator)
	NONE :: 0;
	/// Texture will allocate its own memory (COMMITTED resource)
	OWN_MEMORY_BIT :: 0x01;
	/// Texture will be allocated in memory which can be shared among multiple processes
	EXPORT_BIT :: 0x02;
	/// Texture will be allocated in memory which can be shared among multiple gpus
	EXPORT_ADAPTER_BIT :: 0x04;
	/// Texture will be imported from a handle created in another process
	IMPORT_BIT :: 0x08;
	/// Use ESRAM to store this texture
	ESRAM :: 0x10;
	/// Use on-tile memory to store this texture
	ON_TILE :: 0x20;
	/// Prevent compression meta data from generating (XBox)
	NO_COMPRESSION :: 0x40;
	/// Force 2D instead of automatically determining dimension based on width; height; depth
	FORCE_2D :: 0x80;
	/// Force 3D instead of automatically determining dimension based on width; height; depth
	FORCE_3D :: 0x100;
	/// Display target
	ALLOW_DISPLAY_TARGET :: 0x200;
    /// Create an sRGB texture.
    SRGB :: 0x400;
}

GPUPresetLevel :: enum {
    NONE :: 0;
	OFFICE;    //This means unsupported
	LOW;
	MEDIUM;
	HIGH;
	ULTRA;
	COUNT;
}

QueryType :: enum {
    TIMESTAMP :: 0;
	PIPELINE_STATISTICS;
	OCCLUSION;
	COUNT;
}

DescriptorUpdateFrequency :: enum {
    NONE :: 0;
	PER_FRAME;
	PER_BATCH;
	PER_DRAW;
	COUNT;
}

RootSignatureFlags :: enum_flags {
    /// Default flag
	NONE :: 0;
	/// Local root signature used mainly in raytracing shaders
	LOCAL_BIT :: 0x1;
}

FenceStatus :: enum {
    COMPLETE :: 0;
	INCOMPLETE;
	NOTSUBMITTED;
}

VertexAttribRate :: enum {
    VERTEX :: 0;
	INSTANCE :: 1;
	COUNT;
}

PipelineCacheFlags :: enum_flags {
    NONE :: 0x0;
	EXTERNALLY_SYNCHRONIZED :: 0x1;
}

ShaderTarget :: enum {
    // We only need SM 5.0 for supporting D3D11 fallback
#if defined(DIRECT3D11)
	shader_target_5_0;
#else
    // 5.1 is supported on all DX12 hardware
    shader_target_5_1;
    shader_target_6_0;
	shader_target_6_1;
	shader_target_6_2;
	shader_target_6_3; //required for Raytracing
#endif;
}

GpuMode :: enum {
    SINGLE :: 0;
	LINKED;
	
}

DefaultResourceAlignment :: enum {
    RESOURCE_BUFFER_ALIGNMENT :: 4U;
}

WaveOpsSupportFlags :: enum_flags {
    NONE :: 0x0;
	BASIC_BIT :: 0x00000001;
	VOTE_BIT :: 0x00000002;
	ARITHMETIC_BIT :: 0x00000004;
	BALLOT_BIT :: 0x00000008;
	SHUFFLE_BIT :: 0x00000010;
	SHUFFLE_RELATIVE_BIT :: 0x00000020;
	CLUSTERED_BIT :: 0x00000040;
	QUAD_BIT :: 0x00000080;
	PARTITIONED_BIT_NV :: 0x00000100;
	ALL :: 0x7FFFFFFF;
}

