import os.path
import re
import sys

from pcpp.preprocessor import Preprocessor

this_dir = os.path.dirname(os.path.realpath(__file__))
PATH_TO_THE_FORGE = os.path.realpath(os.path.join(this_dir, "../../../The-Forge"))
assert os.path.isdir(PATH_TO_THE_FORGE), PATH_TO_THE_FORGE

ctx = dict()

def p(*a, **k):
    # a shortcut for printing to the output file
    if "file" not in k and "output_file" in ctx:
        k["file"] = ctx["output_file"]
    print(*a, **k)

def strip_slash_comments(line):
    # naively strip // 
    try:
        idx = line.index("//")
    except ValueError:
        pass
    else:
        line = line[:idx]

    return line


def process_header(header_filename, output_filename):
    header = open(header_filename).read()

    ctx["output_file"] = open(output_filename, "w")
    with ctx["output_file"]:
        p("//\n// AUTOGENERATED\n//\n")

        enum_flags = {}

        # enum flag types are declared like 'MAKE_ENUM_FLAG(uint32_t, ResourceState)'
        enum_flags_re = r"^MAKE_ENUM_FLAG\((\w+),\s*(\w+)\)"
        for match in re.finditer(enum_flags_re, header, re.MULTILINE):
            enum_type = match.group(1)
            enum_name = match.group(2)
            enum_flags[enum_name] = enum_type

        #
        # enums
        #
        #for match in re.finditer(r"typedef enum {([^}]*)} (\w+);", header, re.MULTILINE):
        for match in re.finditer(r"typedef enum (\w+)\s*{([^}]*)} (\w+);", header, re.MULTILINE):
            enum_id = match.group(1).strip()
            enum_id_2 = match.group(3).strip()
            assert enum_id == enum_id_2, enum_id + " vs " + enum_id_2

            enum_contents = match.group(2).strip()\
                .replace("=", "::")\
                .replace(",", ";")

            lines = [l.lstrip().upper() for l in enum_contents.split("\n") if strip_slash_comments(l).strip()]
            if lines and lines[-1].lstrip().startswith("MAX_"): # remove a MAX_ line
                lines = lines[:-1]

            if len(lines) > 1:
                # remove common prefix, since Jai has the unary . for enum values
                prefix = longest_common_prefix(lines)
                if prefix:
                    enum_contents = enum_contents.replace(prefix, "")


            enum_contents = re.sub(r"//.*$", "", enum_contents)

            # TODO: the above removes the last comment in an enum body...we could probably retain them

            if not enum_contents.rstrip().endswith(";"):
                enum_contents = enum_contents.rstrip() + ";"

            enum_type = "enum_flags" if enum_id in enum_flags else "enum"

            p(f"{enum_id} :: {enum_type} {{\n    {enum_contents}\n}}\n")


def longest_common_prefix(strs):
    longest_pre = ""
    if not strs:
        return longest_pre

    shortest_str = min(strs, key=len)

    for i in range(len(shortest_str)):
        if all(x.startswith(shortest_str[:i+1]) for x in strs):
            longest_pre = shortest_str[:i+1]
        else:
            break

    return longest_pre

def process_header_2(path_to_header):
    import CppHeaderParser
    header = CppHeaderParser.CppHeader(path_to_header)

class MyPreprocessor(Preprocessor):
    def on_directive_handle(self, directive, toks, ifpassthru):
        if directive == "include":
            return False

        return super(Preprocessor, self).on_directive_handle(directive, toks, ifpassthru)

def main():
    path_to_header = os.path.join(PATH_TO_THE_FORGE, "Common_3/Renderer/IRenderer.h")

    from io import StringIO
    output_sio = StringIO()

    preprocessor = MyPreprocessor()
    preprocessor.parse(open(path_to_header, "r"))
    preprocessor.write(output_sio)

    process_header_2(path_to_header)

    #process_header(path_to_header, "Renderer.jai")

if __name__ == "__main__":
    main()
