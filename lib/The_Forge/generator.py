import os.path
import re
import sys

import contextlib
import CppHeaderParser
import pprint

from pcpp.preprocessor import Preprocessor

this_dir = os.path.dirname(os.path.realpath(__file__))
PATH_TO_THE_FORGE = os.path.realpath(os.path.join(this_dir, "../../../The-Forge"))
assert os.path.isdir(PATH_TO_THE_FORGE), PATH_TO_THE_FORGE

ctx = dict(indent = 0)

@contextlib.contextmanager
def indent():
    ctx["indent"] += 1
    try:
        yield
    finally:
        ctx["index"] -= 1

def p(*a, **k):
    # a shortcut for printing to the output file
    if "file" not in k and "output_file" in ctx:
        k["file"] = ctx["output_file"]

    if ctx["indent"] > 0:
        print(" " * (4 * ctx["indent"]), file=k["file"], end="")

    print(*a, **k)

def strip_slash_comments(line):
    # naively strip // 
    try:
        idx = line.index("//")
    except ValueError:
        pass
    else:
        line = line[:idx]

    return line


def process_header(header_file, output_filename):
    header = header_file.read()

    ctx["output_file"] = open(output_filename, "w")
    with ctx["output_file"]:
        p("//\n// AUTOGENERATED\n//\n")

        enum_flags = {}

        # enum flag types are declared like 'MAKE_ENUM_FLAG(uint32_t, ResourceState)'
        enum_flags_re = r"^MAKE_ENUM_FLAG\((\w+),\s*(\w+)\)"
        for match in re.finditer(enum_flags_re, header, re.MULTILINE):
            enum_type = match.group(1)
            enum_name = match.group(2)
            enum_flags[enum_name] = enum_type

        #
        # enums
        #
        #for match in re.finditer(r"typedef enum {([^}]*)} (\w+);", header, re.MULTILINE):
        for match in re.finditer(r"typedef enum (\w+)\s*{([^}]*)} (\w+);", header, re.MULTILINE):
            enum_id = match.group(1).strip()
            enum_id_2 = match.group(3).strip()
            assert enum_id == enum_id_2, enum_id + " vs " + enum_id_2

            enum_contents = match.group(2).strip()\
                .replace("=", "::")\
                .replace(",", ";")

            lines = [l.lstrip().upper() for l in enum_contents.split("\n") if strip_slash_comments(l).strip()]
            if lines and lines[-1].lstrip().startswith("MAX_"): # remove a MAX_ line
                lines = lines[:-1]

            if len(lines) > 1:
                # remove common prefix, since Jai has the unary . for enum values
                prefix = longest_common_prefix(lines)
                if prefix:
                    enum_contents = enum_contents.replace(prefix, "")


            enum_contents = re.sub(r"//.*$", "", enum_contents)

            # TODO: the above removes the last comment in an enum body...we could probably retain them

            if not enum_contents.rstrip().endswith(";"):
                enum_contents = enum_contents.rstrip() + ";"

            enum_type = "enum_flags" if enum_id in enum_flags else "enum"

            p(f"{enum_id} :: {enum_type} {{\n    {enum_contents}\n}}\n")


def longest_common_prefix(strs):
    longest_pre = ""
    if not strs:
        return longest_pre

    shortest_str = min(strs, key=len)

    for i in range(len(shortest_str)):
        if all(x.startswith(shortest_str[:i+1]) for x in strs):
            longest_pre = shortest_str[:i+1]
        else:
            break

    return longest_pre

def add_prefix_if_necessary(s):
    if s[0].isdigit():
        return "_" + s
    return s

def process_enum_val(val, prefix = None):
    if isinstance(val, str):
        if prefix:
            val = val.replace(prefix, "")

        val = val.replace("( uint32_t ) ", "")
        if val.startswith("(") and val.endswith(")"):
            val = val[1:-1]
        if val.endswith(" U"):
            val = val[:-2]
        val = val.replace("( ", "(").replace(" )", ")")
        val = val.strip()
    return val

def process_header_2(path_to_header, output_filename):
    header = CppHeaderParser.CppHeader(path_to_header)
    
    out = open("temp.txt", "w")

    pp = pprint.PrettyPrinter(indent=4, stream=out)
    pp.pprint(header.enums)

    ctx['output_file'] = open(output_filename, "w")

    for enum in header.enums:
        did_indent = False

        try:
            p(f"{enum['name']} :: enum {{")
        except KeyError:
            # enums without names are effectively just constants, so pass
            # them through at the file scope.
            pass
        else:
            ctx["indent"] += 1
            did_indent = True

        stripped_names = [enum_val['name'] for enum_val in enum['values']]
        prefix = None
        if did_indent and len(stripped_names) > 1:
            # remove common prefix, since Jai has the unary . for enum
            # values

            last = None
            if stripped_names[-1].startswith("MAX_"):
                last = stripped_names[-1]
                stripped_names = stripped_names[:-1]

            prefix = longest_common_prefix(stripped_names)
            if prefix:
                stripped_names = [add_prefix_if_necessary(name[len(prefix):]) for name in stripped_names]

            if last is not None:
                stripped_names.append(last)


        for i, enum_val in enumerate(enum['values']):
            val = process_enum_val(enum_val.get("raw_value", enum_val['value']), prefix=prefix)
            p(f"{stripped_names[i]} :: {val};")

        if did_indent:
            ctx["indent"] -= 1
            p("}\n")



class MyPreprocessor(Preprocessor):
    def on_directive_handle(self, directive, toks, ifpassthru):

        # skip all #includes
        if directive.value == "include":
            return False

        return super(Preprocessor, self).on_directive_handle(directive, toks, ifpassthru)

def main():
    path_to_header = os.path.join(PATH_TO_THE_FORGE, "Common_3/Renderer/IRenderer.h")

    preprocessor = MyPreprocessor()
    preprocessor.parse(open(path_to_header, "r"))
    
    path_to_preprocessed = "preprocessed.hpp"
    with open(path_to_preprocessed, "w") as preprocessed_file:
        preprocessor.write(preprocessed_file)

    process_header_2(path_to_preprocessed, "Renderer.jai")

    #process_header(open(path_to_header, "r"), "Renderer.jai")

if __name__ == "__main__":
    main()
